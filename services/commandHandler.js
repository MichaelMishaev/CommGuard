const config = require('../config');
const { addToBlacklist, removeFromBlacklist, listBlacklist, isBlacklisted } = require('./blacklistService');
const { addToWhitelist, removeFromWhitelist, listWhitelist, isWhitelisted } = require('./whitelistService');
const { addMutedUser, removeMutedUser, isMuted, getMutedUsers } = require('./muteService');
const { getTimestamp } = require('../utils/logger');
const { sendKickAlert } = require('../utils/alertService');
const searchService = require('./searchService');
const { translationService } = require('./translationService');
const groupJokeSettingsService = require('./groupJokeSettingsService');

// Conditionally load unblacklist request service
let unblacklistRequestService;
if (config.FEATURES.FIREBASE_INTEGRATION) {
    unblacklistRequestService = require('./unblacklistRequestService');
} else {
    // Mock service when Firebase is disabled
    unblacklistRequestService = {
        canMakeRequest: async () => ({ canRequest: false, reason: 'Firebase disabled' }),
        createRequest: async () => false,
        processAdminResponse: async () => false,
        getPendingRequests: async () => []
    };
}

// Track group mute status
const groupMuteStatus = new Map();

class CommandHandler {
    // Track processed messages to prevent duplicates
    static processedMessages = new Set();
    
    constructor(sock) {
        this.sock = sock;
        
        // Sassy Hebrew responses for unauthorized users
        this.sassyResponses = [
            '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?',
            '◊™◊û◊©◊ô◊ö ◊ú◊†◊°◊ï◊™, ◊ê◊ï◊ú◊ô ◊ô◊¶◊ú◊ô◊ó ◊ú◊ö ◊ë◊ê◊ú◊£ ◊î◊ë◊ê',
            '◊ê◊ì◊û◊ô◊ü? ◊ê◊™◊î? üòÇ',
            '◊ó◊ú◊û◊™ ◊©◊ê◊™◊î ◊î◊û◊†◊î◊ú ◊õ◊ê◊ü?',
            '◊®◊ß ◊û◊†◊î◊ú◊ô◊ù ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊î◊©◊™◊û◊© ◊ë◊ñ◊î, ◊ú◊ê ◊õ◊ï◊ú◊ù',
            '◊†◊ó◊û◊ì ◊ú◊†◊°◊ï◊™, ◊ê◊ë◊ú ◊ú◊ê',
            '◊ê◊™◊î ◊û◊ë◊ô◊ü ◊©◊ê◊†◊ô ◊®◊ß ◊¢◊ï◊ë◊ì ◊§◊î? ü§∑‚Äç‚ôÇÔ∏è',
            '◊ô◊© ◊ú◊ö ◊î◊®◊©◊ê◊ï◊™? ◊ú◊ê ◊†◊®◊ê◊î ◊ú◊ô...',
            '◊™◊©◊ê◊ú ◊ê◊™ ◊î◊û◊†◊î◊ú ◊ë◊ë◊ß◊©◊î',
            '◊§◊¢◊ù ◊î◊ë◊ê◊î ◊™◊ß◊ë◊ú ◊î◊®◊©◊ê◊ï◊™ ◊ß◊ï◊ì◊ù',
            '◊ê◊ï◊ß◊ô◊ô, ◊ê◊ë◊ú ◊ú◊ê',
            '◊û◊î ◊ñ◊î ◊î◊©◊ò◊ï◊ô◊ï◊™ ◊î◊ê◊ú◊î?',
            '◊ú◊ê ◊†◊§◊ú ◊ú◊ô ◊î◊ê◊°◊ô◊û◊ï◊ü...',
            '◊ê◊ï◊ú◊ô ◊™◊†◊°◊î ◊¢◊ù ◊ê◊ì◊û◊ô◊ü ◊ê◊û◊ô◊™◊ô?',
            '◊†◊ï ◊ë◊ê◊û◊™... üôÑ'
        ];
    }
    
    // Get a random sassy response for unauthorized users
    getRandomSassyResponse() {
        return this.sassyResponses[Math.floor(Math.random() * this.sassyResponses.length)];
    }
    
    // TEMPORARY: Use direct API with rate limiting until shared cache is implemented
    async getCachedGroupMetadata(groupId) {
        try {
            // Add rate limiting protection
            await new Promise(resolve => setTimeout(resolve, 200));
            return await this.sock.groupMetadata(groupId);
        } catch (error) {
            console.error('Rate limited groupMetadata call:', error);
            throw error;
        }
    }
    
    isPrivateChat(msg) {
        return msg.key.remoteJid.endsWith('@s.whatsapp.net');
    }
    
    async sendGroupOnlyMessage(msg, commandName) {
        await this.sock.sendMessage(msg.key.remoteJid, { 
            text: `‚ö†Ô∏è The ${commandName} command can only be used in groups.` 
        });
    }

    async handleCommand(msg, command, args, isAdmin, isSuperAdmin) {
        const cmd = command.toLowerCase();
        
        try {
            switch (cmd) {
                case '#help':
                    return await this.handleHelp(msg);
                    
                case '#status':
                    return await this.handleStatus(msg);
                    
                case '#mute':
                    return await this.handleMute(msg, args, isAdmin);
                    
                case '#unmute':
                    return await this.handleUnmute(msg, args, isAdmin);
                    
                case '#clear':
                    return await this.handleClear(msg, isAdmin);
                    
                case '#kick':
                    return await this.handleKick(msg, isAdmin);
                    
                case '#ban':
                    return await this.handleBan(msg, isAdmin);
                    
                    
                case '#whitelist':
                    return await this.handleWhitelist(msg, args, isAdmin);
                    
                case '#unwhitelist':
                    return await this.handleUnwhitelist(msg, args, isAdmin);
                    
                case '#whitelst':
                    return await this.handleWhitelistList(msg, isAdmin);
                    
                case '#blacklist':
                    return await this.handleBlacklistAdd(msg, args, isAdmin);
                    
                case '#unblacklist':
                    return await this.handleBlacklistRemove(msg, args, isAdmin);
                    
                case '#blacklst':
                    return await this.handleBlacklistList(msg, isAdmin);
                    
                case '#sweep':
                    return await this.handleSweep(msg, isSuperAdmin);
                    
                case '#botkick':
                    return await this.handleBotKick(msg, isAdmin);
                    
                case '#stats':
                    return await this.handleStats(msg, isAdmin);
                    
                case '#botforeign':
                    return await this.handleBotForeign(msg, isAdmin);
                    
                case '#debugnumbers':
                    return await this.handleDebugNumbers(msg, isAdmin);
                    
                case '#sessioncheck':
                    return await this.handleSessionCheck(msg, isAdmin);
                    
                case '#msg1':
                    return await this.handleMsg1(msg, isAdmin);
                    
                case '#jokestats':
                    return await this.handleJokeStats(msg, isAdmin);
                    
                    
                case '#rejoinlinks':
                    return await this.handleRejoinLinks(msg, args, isAdmin);
                    
                case '#botadmin':
                    return await this.handleBotAdminCheck(msg, isAdmin);
                    
                case '#search':
                    return await this.handleSearch(msg, args, isAdmin);
                    
                case '#verify':
                    return await this.handleVerifyLink(msg, args, isAdmin);
                    
                case '#translate':
                    return await this.handleTranslate(msg, args, isAdmin);
                    
                case '#langs':
                    return await this.handleLanguageList(msg, isAdmin);
                    
                case '#autotranslate':
                case '#translation':
                    return await this.handleTranslationToggle(msg, args);
                    
                case '#jokeson':
                    return await this.handleJokesOn(msg, isAdmin);
                    
                case '#jokesoff':
                    return await this.handleJokesOff(msg, isAdmin);
                    
                case '#jokesstatus':
                    return await this.handleJokesStatus(msg, isAdmin);
                    
                // #free system removed - use admin #unblacklist instead
                
                default:
                    // Check for admin approval patterns (yes/no userId)
                    if (isAdmin && (cmd === 'yes' || cmd === 'no')) {
                        return await this.handleAdminApproval(msg, command, args);
                    }
                    return false; // Command not handled
            }
        } catch (error) {
            console.error(`‚ùå Error handling command ${cmd}:`, error);
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚ùå Error executing command: ${error.message}` 
            });
            return true;
        }
    }

    async handleHelp(msg) {
        // Check if sender is the authorized admin
        const senderId = msg.key.participant || msg.key.remoteJid;
        const senderPhone = senderId.split('@')[0];
        const isPrivateChat = !msg.key.remoteJid.endsWith('@g.us');
        
        // Check if it's admin (handle both regular and LID format)
        const isAdminPhone = senderPhone === config.ALERT_PHONE || 
                           senderPhone === config.ADMIN_PHONE ||
                           senderId.includes(config.ALERT_PHONE) ||
                           senderId.includes(config.ADMIN_PHONE);
        
        // Check if it's specifically the alert phone
        const isAlertPhone = senderPhone === config.ALERT_PHONE || 
                            senderId.includes(config.ALERT_PHONE);
        
        // ONLY allow help command in private chat from admin
        if (!isPrivateChat) {
            // In groups, don't reveal anything about the help command
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå Unknown command.' 
            });
            return true;
        }
        
        // In private chat, check if it's the admin
        if (!isAdminPhone) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: this.getRandomSassyResponse()
            });
            return true;
        }
        
        // Special detailed help for alert phone
        if (isAlertPhone) {
            const detailedHelpText = `üìù *CommGuard Bot - FULL COMMAND REFERENCE*

*‚úÖ WORKING COMMANDS:*

*üîß Basic Commands:*
‚Ä¢ *#status* - Shows bot online status, ID, version, and configuration
‚Ä¢ *#stats* - Displays group statistics (members, admins, etc)
‚Ä¢ *#help* - This command list (private chat only)
‚Ä¢ *#msg1* - Send pre-written admin warning about invite links

*üëÆ Moderation Commands:*
‚Ä¢ *#kick* - Reply to message ‚Üí Kicks user + deletes their message + adds to blacklist (bot only)
‚Ä¢ *#ban* - Reply to message ‚Üí Permanently bans user (same as kick but called ban)
‚Ä¢ *#clear* - ‚ö†Ô∏è NOT IMPLEMENTED (will show "not yet implemented")

*üîá Mute Commands:*
‚Ä¢ *#mute 30* - Mutes entire group for 30 minutes (only admins can speak)
‚Ä¢ *#mute* (reply) - Mutes specific user (deletes all their messages)
‚Ä¢ *#unmute* - Unmutes group or user

*üìã Whitelist Management:*
‚Ä¢ *#whitelist 972555123456* - Adds number to whitelist (bypasses ALL restrictions)
‚Ä¢ *#unwhitelist 972555123456* - Removes from whitelist
‚Ä¢ *#whitelst* - Shows all whitelisted numbers

*üö´ Blacklist Management:*
‚Ä¢ *#blacklist 972555123456* - Adds to blacklist (auto-kicked on join)
‚Ä¢ *#unblacklist 972555123456* - Removes from blacklist
‚Ä¢ *#blacklst* - Shows all blacklisted numbers
‚Ä¢ *#botkick* - Scans current group and kicks all blacklisted members

*üåç Country Restriction:*
‚Ä¢ *#botforeign* - Removes ALL users with +1 (US/Canada) and +6 (Southeast Asia) numbers
  - Protects Israeli numbers (+972)
  - Skips whitelisted users

*üßπ Advanced Commands:*
‚Ä¢ *#sweep* - Removes inactive users (requires superadmin)
‚Ä¢ *#sessioncheck* - Shows session decryption error statistics
‚Ä¢ *#botadmin* - Checks if bot has admin privileges in current group
‚Ä¢ *#debugnumbers* - Shows participant phone formats (for debugging LID issues)

*üîç Search Commands (Requires MCP Setup):*
‚Ä¢ *#search <query>* - Search the web (rate limited: 5/minute)
‚Ä¢ *#verify <url>* - Verify if a link is safe

*üåê Translation Commands (‚úÖ CONFIGURED & READY):*
‚Ä¢ *#translate <text>* - Translate to English (auto-detect source)
‚Ä¢ *#translate <lang> <text>* - Translate to specific language
‚Ä¢ *#langs* - Show supported language codes (20+ languages)
‚Ä¢ *#autotranslate <on/off/status>* - Control auto-translation (bot only)
‚Ä¢ **Auto-Translation** - Bot automatically translates non-Hebrew messages to Hebrew immediately
‚Ä¢ **Smart Detection** - Only translates pure non-Hebrew (ignores mixed Hebrew/English)

*üé≠ Entertainment Commands:*
‚Ä¢ *#jokestats* - View motivational phrase usage statistics
‚Ä¢ *#jokeson* - Enable ◊û◊©◊¢◊û◊ù jokes for this group
‚Ä¢ *#jokesoff* - Disable ◊û◊©◊¢◊û◊ù jokes for this group
‚Ä¢ *#jokesstatus* - Show joke settings for this group
‚Ä¢ **Automatic Jokes** - Bot responds to "◊û◊©◊¢◊û◊ù" with funny Hebrew jokes (125+ jokes)

*üö® AUTO-PROTECTION FEATURES:*
1. **Invite Link Detection** ‚úÖ
   - All users: Immediate kick + blacklist (no warnings)
   - Always: Message deleted + Admin alert
   - Detects: chat.whatsapp.com links

2. **Blacklist Auto-Kick** ‚úÖ
   - When blacklisted user joins ‚Üí Instant kick
   - Admin override: If ADMIN adds blacklisted user ‚Üí Allowed to stay

3. **Country Code Auto-Kick** ‚úÖ
   - Auto-kicks: +1 (US/Canada) and +6x (Southeast Asia)
   - Protected: +972 (Israel) NEVER kicked
   - Admin override: If ADMIN adds restricted user ‚Üí Allowed to stay

4. **Whitelist Bypass** ‚úÖ
   - Whitelisted users bypass ALL restrictions
   - Never kicked for any reason

5. **Anti-Boredom System** ‚úÖ
   - Auto-detects: Messages containing "◊û◊©◊¢◊û◊ù" 
   - Actions: Responds with random funny Hebrew jokes
   - Features: Smart rotation, usage tracking, 125+ modern Hebrew jokes
   - Group Control: Can enable/disable per group (#jokeson/#jokesoff)

*‚öôÔ∏è SPECIAL BEHAVIORS:*
‚Ä¢ Bot needs admin to work (bypass enabled for LID issues)
‚Ä¢ #kick now deletes the target message too
‚Ä¢ All kicks add user to blacklist automatically
‚Ä¢ Muted users kicked after 10 messages
‚Ä¢ Session errors handled automatically

*üîí SECURITY NOTES:*
‚Ä¢ #help only works in private chat
‚Ä¢ #help shows "Unknown command" in groups
‚Ä¢ Only admin phones can access commands
‚Ä¢ Alert phone: ${config.ALERT_PHONE} (YOU)
‚Ä¢ Admin phone: ${config.ADMIN_PHONE}

*üì± BOT STATUS:*
‚Ä¢ Version: 2.1 (Baileys + Enhanced Nationality System)
‚Ä¢ Firebase: ${config.FEATURES.FIREBASE_INTEGRATION ? 'Enabled (Optimized)' : 'Disabled'}
‚Ä¢ Blacklist System: ${config.FEATURES.AUTO_KICK_BLACKLISTED ? 'Enabled (24hr Cache)' : 'Disabled'}
‚Ä¢ Bot Admin Bypass: ${config.FEATURES.BYPASS_BOT_ADMIN_CHECK ? 'Enabled' : 'Disabled'}
‚Ä¢ Country Restrictions: ${config.FEATURES.RESTRICT_COUNTRY_CODES ? 'Enabled' : 'Disabled'}

*üõ°Ô∏è Bot is protecting your groups 24/7!*`;

            await this.sock.sendMessage(msg.key.remoteJid, { text: detailedHelpText });
        } else {
            // Regular help text for admin phone
            const helpText = `üìù *CommGuard Bot Commands*

*üîß Basic Commands:*
‚Ä¢ *#status* - Check bot status and configuration
‚Ä¢ *#stats* - Show group statistics
‚Ä¢ *#msg1* - Send admin warning about invite links

*üëÆ Moderation Commands:* (Reply to message)
‚Ä¢ *#kick* - Remove user from group + blacklist (bot only)
‚Ä¢ *#ban* - Permanently ban user from group
‚Ä¢ *#clear* - Clear messages (not yet implemented)

*üîá Mute Commands:*
‚Ä¢ *#mute [minutes]* - Mute entire group (admin only)
‚Ä¢ *#mute (reply) [minutes]* - Mute specific user
‚Ä¢ *#unmute* - Unmute group/user

*üìã Whitelist Management:*
‚Ä¢ *#whitelist [number]* - Add number to whitelist
‚Ä¢ *#unwhitelist [number]* - Remove from whitelist  
‚Ä¢ *#whitelst* - List whitelisted numbers

*üö´ Blacklist Management:*
‚Ä¢ *#blacklist [number]* - Add to blacklist
‚Ä¢ *#unblacklist [number]* - Remove from blacklist
‚Ä¢ *#blacklst* - List blacklisted numbers
‚Ä¢ *#botkick* - Scan group and kick all blacklisted users

*üåç Country Restriction:*
‚Ä¢ *#botforeign* - Remove all +1 and +6 users from group

*üßπ Advanced Commands:*
‚Ä¢ *#sweep* - Clean up inactive users (superadmin)
‚Ä¢ *#sessioncheck* - Check for session decryption errors
‚Ä¢ *#botadmin* - Check if bot has admin privileges
‚Ä¢ *#jokestats* - View joke usage statistics

*üé≠ Joke Control Commands:*
‚Ä¢ *#jokeson* - Enable ◊û◊©◊¢◊û◊ù jokes in this group
‚Ä¢ *#jokesoff* - Disable ◊û◊©◊¢◊û◊ù jokes in this group
‚Ä¢ *#jokesstatus* - Show joke settings for this group

*üö® Auto-Protection Features:*
‚Ä¢ **Invite Link Detection** - Auto-kick + blacklist
‚Ä¢ **Blacklist Enforcement** - Auto-kick banned users
‚Ä¢ **Country Code Restriction** - Auto-kick +1 and +6 numbers
‚Ä¢ **Whitelist Protection** - Bypass all restrictions
‚Ä¢ **Anti-Boredom System** - Responds to "◊û◊©◊¢◊û◊ù" with Hebrew jokes (per-group control)

*üí° Usage Examples:*
‚Ä¢ Kick user: Bot-only automated moderation
‚Ä¢ Mute group: \`#mute 30\` (30 minutes)
‚Ä¢ Add to whitelist: \`#whitelist 972555123456\`
‚Ä¢ Remove all foreign users: \`#botforeign\`
‚Ä¢ Get jokes: Any message with "◊û◊©◊¢◊û◊ù" ‚Üí Bot responds with humor
‚Ä¢ View joke stats: \`#jokestats\`
‚Ä¢ Control jokes: \`#jokesoff\` ‚Üí Disable jokes in this group
‚Ä¢ Enable jokes: \`#jokeson\` ‚Üí Enable jokes in this group
‚Ä¢ Check joke status: \`#jokesstatus\` ‚Üí Show current settings
‚Ä¢ Translate text: \`#translate ◊©◊ú◊ï◊ù ◊¢◊ï◊ú◊ù\` ‚Üí "Hello world" ‚úÖ READY
‚Ä¢ Translate to Hebrew: \`#translate he Good morning\` ‚Üí "◊ë◊ï◊ß◊® ◊ò◊ï◊ë" ‚úÖ READY
‚Ä¢ Auto-translate: Send "Hello world" ‚Üí Bot shows Hebrew translation immediately ‚úÖ ACTIVE
‚Ä¢ Control auto-translate: \`#autotranslate off\` ‚Üí Bot only ‚úÖ READY

*‚ö†Ô∏è Important Notes:*
‚Ä¢ Most commands require admin privileges
‚Ä¢ Cannot kick/ban other admins
‚Ä¢ Whitelisted users bypass all restrictions
‚Ä¢ All actions are logged and tracked

*üîí Security Notice:*
‚Ä¢ This command list is PRIVATE
‚Ä¢ Only accessible via DM to authorized admin
‚Ä¢ #help is disabled in groups for security

*üõ°Ô∏è Bot protects your groups 24/7 automatically!*`;

            await this.sock.sendMessage(msg.key.remoteJid, { text: helpText });
        }
        return true;
    }

    async handleStatus(msg) {
        const botId = this.sock.user.id;
        const statusText = `ü§ñ *CommGuard Bot Status*

‚úÖ *Online and Active*
üÜî Bot ID: ${botId}
üì± Version: 2.0 (Baileys)
‚è∞ Current Time: ${getTimestamp()}

*Features Status:*
‚Ä¢ Invite Link Detection: ‚úÖ Active
‚Ä¢ Auto-kick Blacklisted: ‚úÖ Active
‚Ä¢ Firebase Integration: ‚úÖ Connected (guard1-d43a3)
‚Ä¢ Mute System: ‚úÖ Active
‚Ä¢ Whitelist System: ‚úÖ Active

*Configuration:*
‚Ä¢ Admin Phone: ${config.ADMIN_PHONE}
‚Ä¢ Alert Phone: ${config.ALERT_PHONE}
‚Ä¢ Kick Cooldown: ${config.KICK_COOLDOWN / 1000}s

üõ°Ô∏è *Protecting your groups 24/7*`;

        await this.sock.sendMessage(msg.key.remoteJid, { text: statusText });
        return true;
    }

    async handleMute(msg, args, isAdmin) {
        console.log(`[${require('../utils/logger').getTimestamp()}] üîá Mute command received from ${msg.key.participant || msg.key.remoteJid}`);
        
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }
        
        // Check if in private chat
        if (this.isPrivateChat(msg)) {
            await this.sendGroupOnlyMessage(msg, '#mute');
            return true;
        }
        
        // Add extra logging for debugging
        console.log(`[${require('../utils/logger').getTimestamp()}] üîç Mute command details:`, {
            hasQuoted: !!(msg.message?.extendedTextMessage?.contextInfo?.quotedMessage),
            args: args,
            messageStructure: Object.keys(msg.message || {})
        });

        const groupId = msg.key.remoteJid;
        const hasQuotedMsg = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;

        if (hasQuotedMsg) {
            // Mute specific user
            return await this.handleMuteUser(msg, args);
        } else {
            // Mute entire group
            return await this.handleMuteGroup(msg, args);
        }
    }

    async handleMuteGroup(msg, args) {
        const argsString = Array.isArray(args) ? args[0] : args;
        const minutes = parseInt(argsString, 10);
        if (!minutes || minutes <= 0) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚ö†Ô∏è Please specify valid minutes. Example: #mute 10\n` +
                      `‚ö†Ô∏è ◊ê◊†◊ê ◊¶◊ô◊ô◊ü ◊ì◊ß◊ï◊™ ◊ó◊ï◊ß◊ô◊ï◊™. ◊ì◊ï◊í◊û◊î: #mute 10`
            });
            return true;
        }

        const groupId = msg.key.remoteJid;
        const muteUntil = Date.now() + (minutes * 60000);
        
        groupMuteStatus.set(groupId, muteUntil);

        await this.sock.sendMessage(groupId, { 
            text: `üîá ◊î◊ß◊ë◊ï◊¶◊î ◊î◊ï◊©◊™◊ß◊î ◊ú-${minutes} ◊ì◊ß◊ï◊™\n` +
                  `üëÆ‚Äç‚ôÇÔ∏è ◊®◊ß ◊û◊†◊î◊ú◊ô◊ù ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊©◊ú◊ï◊ó ◊î◊ï◊ì◊¢◊ï◊™`
        });

        // Auto-unmute after specified time
        setTimeout(async () => {
            groupMuteStatus.delete(groupId);
            await this.sock.sendMessage(groupId, { 
                text: `üîä Group has been unmuted. Everyone can now send messages.\n` +
                      `üîä ◊î◊ß◊ë◊ï◊¶◊î ◊©◊ï◊ó◊®◊®◊î ◊û◊î◊î◊©◊™◊ß◊î. ◊õ◊ï◊ú◊ù ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊©◊ú◊ï◊ó ◊î◊ï◊ì◊¢◊ï◊™ ◊¢◊õ◊©◊ô◊ï.`
            });
        }, minutes * 60000);

        return true;
    }

    async handleMuteUser(msg, args) {
        // Implementation for muting specific user
        const argsString = Array.isArray(args) ? args.join(' ') : args;
        const parts = argsString.split(' ');
        const minutes = parseInt(parts[0], 10) || 60; // Default 1 hour
        
        if (minutes <= 0) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚ö†Ô∏è Please specify valid minutes. Example: #mute 30\n` +
                      `‚ö†Ô∏è ◊ê◊†◊ê ◊¶◊ô◊ô◊ü ◊ì◊ß◊ï◊™ ◊ó◊ï◊ß◊ô◊ï◊™. ◊ì◊ï◊í◊û◊î: #mute 30`
            });
            return true;
        }

        const quotedMsg = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant;
        
        if (!quotedMsg || !quotedParticipant) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚ö†Ô∏è Please reply to a message to mute that user.\n` +
                      `‚ö†Ô∏è ◊ê◊†◊ê ◊î◊©◊ë ◊ú◊î◊ï◊ì◊¢◊î ◊õ◊ì◊ô ◊ú◊î◊©◊™◊ô◊ß ◊ê◊™ ◊î◊û◊©◊™◊û◊©.`
            });
            return true;
        }

        // Extract user ID from quoted message
        const userToMute = quotedParticipant;
        const muteUntil = Date.now() + (minutes * 60000);
        
        // Add user to mute service
        const success = await addMutedUser(userToMute, muteUntil);
        
        if (success) {
            const muteEndTime = new Date(muteUntil).toLocaleString('en-GB', {
                day: '2-digit',
                month: '2-digit', 
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `üîá User muted for ${minutes} minutes until ${muteEndTime}\n` +
                      `üóëÔ∏è All their messages will be automatically deleted\n\n` +
                      `üîá ◊î◊û◊©◊™◊û◊© ◊î◊ï◊©◊™◊ß ◊ú-${minutes} ◊ì◊ß◊ï◊™ ◊¢◊ì ${muteEndTime}\n` +
                      `üóëÔ∏è ◊õ◊ú ◊î◊î◊ï◊ì◊¢◊ï◊™ ◊©◊ú◊ï ◊ô◊ô◊û◊ó◊ß◊ï ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™`
            });
        } else {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚ùå Failed to mute user. Please try again.\n` +
                      `‚ùå ◊†◊õ◊©◊ú ◊ë◊î◊©◊™◊ß◊™ ◊î◊û◊©◊™◊û◊©. ◊ê◊†◊ê ◊†◊°◊î ◊©◊ï◊ë.`
            });
        }

        return true;
    }

    isGroupMuted(groupId) {
        const muteUntil = groupMuteStatus.get(groupId);
        if (!muteUntil) return false;
        
        if (Date.now() >= muteUntil) {
            groupMuteStatus.delete(groupId);
            return false;
        }
        
        return true;
    }

    async handleStats(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        // Check if in private chat
        if (this.isPrivateChat(msg)) {
            // Show general bot statistics
            const { blacklistCache } = require('./blacklistService');
            const { listWhitelist } = require('./whitelistService');
            const mutedUsers = getMutedUsers();
            const activeMutes = Array.from(mutedUsers.entries()).filter(([id, muteUntil]) => Date.now() < muteUntil).length;
            
            // Get whitelist count
            const whitelistCount = (await listWhitelist()).length;
            
            // Get group information
            let totalGroups = 0;
            let adminGroups = 0;
            try {
                const groups = await this.sock.groupFetchAllParticipating();
                totalGroups = Object.keys(groups).length;
                
                // Count groups where bot is admin
                for (const groupId in groups) {
                    const group = groups[groupId];
                    const botId = this.sock.user.id;
                    const botParticipant = group.participants.find(p => {
                        // Check various ID formats
                        return p.id === botId || 
                               p.id === '171012763213843@lid' || // Known bot LID
                               p.id.includes(botId.split(':')[0].split('@')[0]);
                    });
                    
                    if (botParticipant && (botParticipant.admin === 'admin' || botParticipant.admin === 'superadmin')) {
                        adminGroups++;
                    }
                }
            } catch (error) {
                console.error('Error fetching groups:', error);
            }
            
            const statsText = `üìä *Bot Statistics*

üë• *Total Groups:* ${totalGroups}
üëÆ *Admin in Groups:* ${adminGroups}
üö´ *Blacklisted Users:* ${blacklistCache.size}
‚úÖ *Whitelisted Users:* ${whitelistCount}
üîá *Currently Muted:* ${activeMutes}
üî• *Firebase:* ${global.FIREBASE_QUOTA_EXHAUSTED ? 'Quota Exhausted (Memory-only)' : 'Connected'} (${config.FEATURES.FIREBASE_INTEGRATION ? 'Enabled' : 'Disabled'})
üåç *Country Filter:* ${config.FEATURES.RESTRICT_COUNTRY_CODES ? 'Active' : 'Inactive'}

‚è∞ *Generated:* ${getTimestamp()}`;

            await this.sock.sendMessage(msg.key.remoteJid, { text: statsText });
            return true;
        }

        // Group statistics
        try {
            const groupMetadata = await this.getCachedGroupMetadata(msg.key.remoteJid);
            const participants = groupMetadata.participants;
            
            const adminCount = participants.filter(p => p.admin === 'admin' || p.admin === 'superadmin').length;
            const memberCount = participants.length;
            
            const mutedUsers = getMutedUsers();
            const activeMutes = Array.from(mutedUsers.entries()).filter(([id, muteUntil]) => Date.now() < muteUntil).length;

            const statsText = `üìä *Group Statistics*

üë• *Members:* ${memberCount}
üëÆ *Admins:* ${adminCount}
üîá *Muted Users:* ${activeMutes}
üìù *Group Name:* ${groupMetadata.subject}
üÜî *Group ID:* ${groupMetadata.id}

‚è∞ *Generated:* ${getTimestamp()}`;

            await this.sock.sendMessage(msg.key.remoteJid, { text: statsText });
        } catch (error) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå Failed to get group statistics.' 
            });
        }
        
        return true;
    }

    // Add more command handlers here...
    async handleKick(msg, isAdmin) {
        console.log(`[${require('../utils/logger').getTimestamp()}] üîç #kick command received from ${isAdmin ? 'admin' : 'user'}`);

        // Debug log the entire message structure
        console.log(`[${require('../utils/logger').getTimestamp()}] üì¶ Message structure:`, {
            messageKeys: Object.keys(msg.message || {}),
            hasExtendedText: !!msg.message?.extendedTextMessage,
            contextInfoKeys: msg.message?.extendedTextMessage?.contextInfo ? Object.keys(msg.message.extendedTextMessage.contextInfo) : []
        });

        // Check if user is admin (allow both manual admin kicks and automated bot kicks)
        if (!isAdmin && !msg.key.fromMe) {
            await this.sock.sendMessage(msg.key.remoteJid, {
                text: '‚ùå Only admins can kick users.'
            });
            return true;
        }

        // Check if in private chat
        if (this.isPrivateChat(msg)) {
            await this.sock.sendMessage(msg.key.remoteJid, {
                text: '‚ö†Ô∏è The #kick command can only be used in groups.\n\nUsage: Reply to a user\'s message in a group and type #kick'
            });
            return true;
        }

        // Check if this is a reply to another message - updated detection logic
        let quotedMsg = null;
        let targetUserId = null;
        let messageId = null;

        // Primary method - extendedTextMessage with contextInfo (most common)
        if (msg.message?.extendedTextMessage?.contextInfo) {
            const contextInfo = msg.message.extendedTextMessage.contextInfo;

            // The participant field contains the user who sent the quoted message
            targetUserId = contextInfo.participant;

            // Get message ID from stanzaId
            messageId = contextInfo.stanzaId;

            // Store the full context for later use
            quotedMsg = contextInfo;

            console.log(`[${require('../utils/logger').getTimestamp()}] ‚úÖ Found quoted message via extendedTextMessage`);
        }

        console.log(`[${require('../utils/logger').getTimestamp()}] üîç Kick command analysis:`, {
            hasQuotedMsg: !!quotedMsg,
            hasParticipant: !!targetUserId,
            participant: targetUserId,
            messageId: messageId,
            messageType: Object.keys(msg.message || {})[0]
        });

        if (!quotedMsg || !targetUserId) {
            await this.sock.sendMessage(msg.key.remoteJid, {
                text: '‚ö†Ô∏è Please reply to a message from the user you want to kick.\n\nUsage: Reply to a user\'s message and type #kick'
            });
            return true;
        }

        const groupId = msg.key.remoteJid;
        // targetUserId already assigned above
        
        try {
            // Get group metadata to check permissions
            const groupMetadata = await this.getCachedGroupMetadata(groupId);
            
            // Check if target user is admin
            const targetParticipant = groupMetadata.participants.find(p => p.id === targetUserId);
            if (targetParticipant && (targetParticipant.admin === 'admin' || targetParticipant.admin === 'superadmin')) {
                await this.sock.sendMessage(groupId, { 
                    text: '‚ùå Cannot kick admin users.' 
                });
                return true;
            }

            // Check if target user is still in group
            if (!targetParticipant) {
                await this.sock.sendMessage(groupId, { 
                    text: '‚ùå User is not in this group.' 
                });
                return true;
            }

            console.log(`[${require('../utils/logger').getTimestamp()}] üë¢ Admin kick: ${targetUserId} from ${groupId}`);

            // Delete the replied-to message first
            if (messageId) {
                try {
                    await this.sock.sendMessage(groupId, {
                        delete: {
                            remoteJid: groupId,
                            fromMe: false,
                            id: messageId,
                            participant: targetUserId
                        }
                    });
                    console.log(`[${require('../utils/logger').getTimestamp()}] üóëÔ∏è Deleted target user's message (ID: ${messageId})`);
                } catch (deleteError) {
                    console.error(`[${require('../utils/logger').getTimestamp()}] ‚ö†Ô∏è Failed to delete target message:`, deleteError.message);
                    // Try alternative deletion method
                    try {
                        await this.sock.sendMessage(groupId, { 
                            delete: {
                                remoteJid: groupId,
                                fromMe: false,
                                id: messageId
                            }
                        });
                        console.log(`[${require('../utils/logger').getTimestamp()}] üóëÔ∏è Deleted target message (alternative method)`);
                    } catch (altError) {
                        console.error(`[${require('../utils/logger').getTimestamp()}] ‚ùå Both deletion methods failed:`, altError.message);
                    }
                }
            } else {
                console.log(`[${require('../utils/logger').getTimestamp()}] ‚ö†Ô∏è No message ID found for deletion - skipping message deletion`);
            }

            // Delete the #kick command message
            try {
                await this.sock.sendMessage(groupId, { 
                    delete: msg.key 
                });
                console.log(`[${require('../utils/logger').getTimestamp()}] üóëÔ∏è Deleted #kick command message`);
            } catch (deleteError) {
                console.error(`[${require('../utils/logger').getTimestamp()}] ‚ö†Ô∏è Failed to delete #kick message:`, deleteError);
            }

            // Kick the user with retry logic for large groups
            let kickSuccessful = false;
            let kickError = null;
            const maxRetries = 3;
            const retryDelay = 2000; // 2 seconds between retries
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    console.log(`[${require('../utils/logger').getTimestamp()}] ü¶µ Attempting to kick user (attempt ${attempt}/${maxRetries})...`);
                    
                    // Set a timeout for the kick operation (10 seconds for large groups)
                    const kickPromise = this.sock.groupParticipantsUpdate(groupId, [targetUserId], 'remove');
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Kick operation timed out after 10 seconds')), 10000)
                    );
                    
                    await Promise.race([kickPromise, timeoutPromise]);
                    
                    kickSuccessful = true;
                    console.log(`[${require('../utils/logger').getTimestamp()}] ‚úÖ Successfully kicked user on attempt ${attempt}`);
                    break;
                } catch (error) {
                    kickError = error;
                    console.error(`[${require('../utils/logger').getTimestamp()}] ‚ùå Kick attempt ${attempt} failed:`, error.message);
                    
                    if (attempt < maxRetries) {
                        console.log(`[${require('../utils/logger').getTimestamp()}] ‚è≥ Waiting ${retryDelay/1000} seconds before retry...`);
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                        
                        // Check if user is still in group before retrying
                        try {
                            const updatedMetadata = await this.sock.groupMetadata(groupId);
                            const stillInGroup = updatedMetadata.participants.some(p => p.id === targetUserId);
                            if (!stillInGroup) {
                                console.log(`[${require('../utils/logger').getTimestamp()}] ‚úÖ User already removed from group`);
                                kickSuccessful = true;
                                break;
                            }
                        } catch (metadataError) {
                            console.error(`[${require('../utils/logger').getTimestamp()}] ‚ö†Ô∏è Could not verify group membership:`, metadataError.message);
                        }
                    }
                }
            }
            
            if (!kickSuccessful) {
                console.error(`[${require('../utils/logger').getTimestamp()}] ‚ùå Failed to kick user after ${maxRetries} attempts`);
                await this.sock.sendMessage(groupId, { 
                    text: `‚ö†Ô∏è Failed to kick user after ${maxRetries} attempts. This sometimes happens in large groups.\n\nError: ${kickError?.message || 'Unknown error'}\n\nPlease try again or kick manually.` 
                });
                return true;
            }

            // Add to blacklist (no group message sent)
            const { addToBlacklist } = require('./blacklistService');
            await addToBlacklist(targetUserId, 'Kicked by admin command');

            // Send alert to alert phone
            const userPhone = targetUserId.split('@')[0];
            
            // Get group invite link
            let groupInviteLink = 'N/A';
            try {
                const inviteCode = await this.sock.groupInviteCode(groupId);
                groupInviteLink = `https://chat.whatsapp.com/${inviteCode}`;
            } catch (err) {
                console.log('Could not get group invite link:', err.message);
            }

            await sendKickAlert(this.sock, {
                userPhone: userPhone,
                userName: `User ${userPhone}`,
                groupName: groupMetadata?.subject || 'Unknown Group',
                groupId: groupId,
                reason: 'admin_command',
                additionalInfo: 'Kicked by admin using #kick command',
                groupInviteLink: groupInviteLink
            });

            // Send notification to admin instead of user
            try {
                await this.sock.sendMessage('0544345287@s.whatsapp.net', {
                    text: `üëÆ‚Äç‚ôÇÔ∏è User kicked by admin command\n\n` +
                          `üë§ User: ${targetUserId}\n` +
                          `üìç Group: ${groupMetadata?.subject || 'Unknown Group'}\n` +
                          `üì± Reason: Manual kick by admin\n` +
                          `‚è∞ Time: ${new Date().toLocaleString()}`
                });
                console.log(`‚úÖ Admin notification sent for kicked user: ${targetUserId}`);
            } catch (notificationError) {
                console.error(`Failed to send admin notification:`, notificationError.message);
            }

            console.log(`[${require('../utils/logger').getTimestamp()}] ‚úÖ Successfully kicked user: ${targetUserId}`);

        } catch (error) {
            console.error(`[${require('../utils/logger').getTimestamp()}] ‚ùå Failed to kick user:`, error);
            await this.sock.sendMessage(groupId, { 
                text: '‚ùå Need to be an admin' 
            });
        }

        return true;
    }

    async handleClear(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        // Check if in private chat
        if (this.isPrivateChat(msg)) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è The #clear command can only be used in groups.\n\nUsage: In a group, type #clear to clear recent messages' 
            });
            return true;
        }

        await this.sock.sendMessage(msg.key.remoteJid, { 
            text: '‚ö†Ô∏è Clear command not yet implemented in Baileys version.' 
        });
        return true;
    }

    async handleWhitelist(msg, args, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        if (!args) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è Please provide a phone number. Example: #whitelist 972555123456' 
            });
            return true;
        }

        const success = await addToWhitelist(args);
        if (success) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚úÖ Added ${args} to whitelist.` 
            });
        } else {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚ùå Failed to add ${args} to whitelist (may already exist).` 
            });
        }
        return true;
    }

    async handleWhitelistList(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        const whitelisted = await listWhitelist();
        if (whitelisted.length === 0) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: 'üìù Whitelist is empty.' 
            });
        } else {
            const list = whitelisted.map((num, index) => `${index + 1}. ${num}`).join('\n');
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `üìù *Whitelisted Users:*\n\n${list}` 
            });
        }
        return true;
    }

    async handleBan(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö??' 
            });
            return true;
        }

        // Check if in private chat
        if (this.isPrivateChat(msg)) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è The #ban command can only be used in groups.\n\nUsage: Reply to a user\'s message in a group and type #ban' 
            });
            return true;
        }

        // Check if this is a reply to another message
        const quotedMsg = msg.message?.extendedTextMessage?.contextInfo;
        if (!quotedMsg || !quotedMsg.participant) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è Please reply to a message from the user you want to ban.\n\nUsage: Reply to a user\'s message and type #ban' 
            });
            return true;
        }

        const groupId = msg.key.remoteJid;
        const targetUserId = quotedMsg.participant;
        
        try {
            // Get group metadata to check permissions
            const groupMetadata = await this.getCachedGroupMetadata(groupId);
            
            // Check if target user is admin
            const targetParticipant = groupMetadata.participants.find(p => p.id === targetUserId);
            if (targetParticipant && (targetParticipant.admin === 'admin' || targetParticipant.admin === 'superadmin')) {
                await this.sock.sendMessage(groupId, { 
                    text: '‚ùå Cannot ban admin users.' 
                });
                return true;
            }

            console.log(`[${require('../utils/logger').getTimestamp()}] üö´ Admin ban: ${targetUserId} from ${groupId}`);

            // Add to blacklist first - must succeed before kicking
            const { addToBlacklist } = require('./blacklistService');
            const blacklistSuccess = await addToBlacklist(targetUserId, 'Banned by admin command');
            if (!blacklistSuccess) {
                await this.sock.sendMessage(groupId, { 
                    text: '‚ùå Failed to add user to blacklist. Ban command aborted.' 
                });
                return true;
            }

            // Then kick the user if they're still in group (only if blacklisting succeeded)
            if (targetParticipant) {
                await this.sock.groupParticipantsUpdate(groupId, [targetUserId], 'remove');
                
                // Send alert to alert phone  
                const userPhone = targetUserId.split('@')[0];
                
                // Get group invite link
                let groupInviteLink = 'N/A';
                try {
                    const inviteCode = await this.sock.groupInviteCode(groupId);
                    groupInviteLink = `https://chat.whatsapp.com/${inviteCode}`;
                } catch (err) {
                    console.log('Could not get group invite link:', err.message);
                }
                
                await sendKickAlert(this.sock, {
                    userPhone: userPhone,
                    userName: `User ${userPhone}`,
                    groupName: groupMetadata?.subject || 'Unknown Group',
                    groupId: groupId,
                    reason: 'admin_command',
                    additionalInfo: 'Banned by admin using #ban command',
                    groupInviteLink: groupInviteLink
                });
                
                // Send ban notification to admin instead of user
                try {
                    await this.sock.sendMessage('0544345287@s.whatsapp.net', {
                        text: `üö´ User banned by admin command\n\n` +
                              `üë§ User: ${targetUserId}\n` +
                              `üìç Group: ${groupMetadata?.subject || 'Unknown Group'}\n` +
                              `üì± Reason: Manual ban by admin\n` +
                              `üóÉÔ∏è Added to blacklist\n` +
                              `‚è∞ Time: ${new Date().toLocaleString()}`
                    });
                    console.log(`‚úÖ Admin notification sent for banned user: ${targetUserId}`);
                } catch (notificationError) {
                    console.error(`Failed to send admin notification:`, notificationError.message);
                }
                
                await this.sock.sendMessage(groupId, { 
                    text: `üö´ User has been banned and removed from the group.\nThey cannot rejoin until unbanned.` 
                });
            } else {
                await this.sock.sendMessage(groupId, { 
                    text: `üö´ User has been banned and cannot join this group.` 
                });
            }

            console.log(`[${require('../utils/logger').getTimestamp()}] ‚úÖ Successfully banned user: ${targetUserId}`);

        } catch (error) {
            console.error(`[${require('../utils/logger').getTimestamp()}] ‚ùå Failed to ban user:`, error);
            await this.sock.sendMessage(groupId, { 
                text: '‚ùå Need to be an admin' 
            });
        }

        return true;
    }


    async handleBotForeign(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        // Check if in private chat
        if (this.isPrivateChat(msg)) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è The #botforeign command can only be used in groups.\n\nUsage: In a group, type #botforeign to remove all users with +1 or +6 country codes' 
            });
            return true;
        }

        const groupId = msg.key.remoteJid;
        
        try {
            // Get group metadata
            const groupMetadata = await this.getCachedGroupMetadata(groupId);
            const participants = groupMetadata.participants;
            
            // Find all users with +1 or +6 country codes
            const usersToKick = [];
            const whitelistedSkipped = [];
            
            for (const participant of participants) {
                const userId = participant.id;
                const phoneNumber = userId.split('@')[0];
                const isLidFormat = userId.endsWith('@lid');
                
                // Debug: Log all phone numbers to see format
                console.log(`üîç Checking participant: ${phoneNumber} (length: ${phoneNumber.length}, LID: ${isLidFormat})`);
                
                // Skip bot and admins
                if (participant.admin === 'admin' || participant.admin === 'superadmin') {
                    console.log(`üëÆ Skipping admin: ${phoneNumber}`);
                    continue;
                }
                
                // Check if user is whitelisted
                if (await isWhitelisted(userId)) {
                    if (phoneNumber.startsWith('1') || phoneNumber.startsWith('6') || 
                        phoneNumber.startsWith('+1') || phoneNumber.startsWith('+6')) {
                        whitelistedSkipped.push(phoneNumber);
                    }
                    continue;
                }
                
                // Check if phone number starts with +1 or +6
                // More precise check: US/Canada (+1) has 11 digits, Southeast Asia (+6x) has varying lengths
                // IMPORTANT: Never kick Israeli numbers (+972)
                const isIsraeliNumber = phoneNumber.startsWith('972') || phoneNumber.startsWith('+972');
                
                // Debug: Show detailed condition checking
                const startsWithOne = phoneNumber.startsWith('1');
                const startsWithPlusOne = phoneNumber.startsWith('+1');
                const startsWithSix = phoneNumber.startsWith('6');
                const startsWithPlusSix = phoneNumber.startsWith('+6');
                const lengthEleven = phoneNumber.length === 11;
                const lengthTwelve = phoneNumber.length === 12;
                const lengthTenToTwelve = phoneNumber.length >= 10 && phoneNumber.length <= 12;
                const lengthElevenToThirteen = phoneNumber.length >= 11 && phoneNumber.length <= 13;
                
                // Also check for US numbers stored as 10 digits (without country code)
                const isTenDigitUSNumber = phoneNumber.length === 10 && /^[2-9]\d{9}$/.test(phoneNumber); // US format without +1
                
                console.log(`üìä ${phoneNumber}: starts1=${startsWithOne}, starts+1=${startsWithPlusOne}, starts6=${startsWithSix}, starts+6=${startsWithPlusSix}, len=${phoneNumber.length}, israeli=${isIsraeliNumber}, 10digitUS=${isTenDigitUSNumber}, isLID=${isLidFormat}`);
                
                // CRITICAL FIX: LID format users are exempt from country code restrictions
                // @lid identifiers are encrypted privacy IDs, NOT phone numbers
                if (isLidFormat) {
                    console.log(`üîí LID format user exempt from country restrictions: ${phoneNumber} (encrypted privacy ID)`);
                }
                
                // Only match if it's clearly a US/Canada or Southeast Asian number AND NOT Israeli AND NOT LID format
                if (!isIsraeliNumber && !isLidFormat && 
                    ((startsWithOne && lengthEleven) || // US/Canada format with 1
                     (startsWithPlusOne && lengthTwelve) || // US/Canada with +1
                     isTenDigitUSNumber || // US format without country code (10 digits)
                     (startsWithSix && lengthTenToTwelve) || // Southeast Asia
                     (startsWithPlusSix && lengthElevenToThirteen))) { // Southeast Asia with +
                    
                    console.log(`üåç Adding to kick list: ${phoneNumber} (length: ${phoneNumber.length})`);
                    usersToKick.push({
                        id: userId,
                        phone: phoneNumber,
                        countryCode: phoneNumber.startsWith('+') ? phoneNumber.substring(0, 2) : phoneNumber.charAt(0)
                    });
                } else if (isIsraeliNumber) {
                    console.log(`üáÆüá± Protecting Israeli number: ${phoneNumber}`);
                } else {
                    console.log(`‚ùå No match for ${phoneNumber} - not US/Canada/SE Asia format`);
                }
            }
            
            if (usersToKick.length === 0) {
                let message = '‚úÖ No users with +1 or +6 country codes found in this group.';
                if (whitelistedSkipped.length > 0) {
                    message += `\n\n‚ÑπÔ∏è ${whitelistedSkipped.length} whitelisted user(s) were skipped.`;
                }
                await this.sock.sendMessage(groupId, { text: message });
                return true;
            }
            
            // Send initial message
            await this.sock.sendMessage(groupId, { 
                text: `üåç Starting to remove ${usersToKick.length} user(s) with restricted country codes (+1 and +6)...` 
            });
            
            // Kick users in batches with delay
            let successCount = 0;
            let failCount = 0;
            
            for (const user of usersToKick) {
                try {
                    await this.sock.groupParticipantsUpdate(groupId, [user.id], 'remove');
                    successCount++;
                    console.log(`‚úÖ Kicked foreign user: ${user.phone}`);
                    
                    // Send alert to alert phone
                    await sendKickAlert(this.sock, {
                        userPhone: user.phone,
                        userName: `User ${user.phone}`,
                        groupName: groupMetadata?.subject || 'Unknown Group',
                        groupId: groupId,
                        reason: 'country_code',
                        additionalInfo: `Foreign country code restriction (+1/+6)`,
                        groupInviteLink: 'N/A' // Will be obtained by alert service
                    });
                    
                    // Send notification to admin instead of user
                    try {
                        await this.sock.sendMessage('0544345287@s.whatsapp.net', {
                            text: `üåç Country code restriction kick\n\n` +
                                  `üë§ User: ${user.phone}\n` +
                                  `üìç Group: ${groupMetadata?.subject || 'Unknown Group'}\n` +
                                  `üì± Reason: +1/+6 country code not allowed\n` +
                                  `‚è∞ Time: ${new Date().toLocaleString()}`
                        });
                    } catch (notificationError) {
                        console.error(`Failed to send admin notification:`, notificationError.message);
                    }
                    
                    // Small delay to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 500));
                } catch (error) {
                    failCount++;
                    console.error(`‚ùå Failed to kick ${user.phone}:`, error.message);
                }
            }
            
            // Send summary
            let summaryMessage = `üåç *Foreign User Removal Complete*\n\n`;
            summaryMessage += `‚úÖ Successfully removed: ${successCount} users\n`;
            if (failCount > 0) {
                summaryMessage += `‚ùå Failed to remove: ${failCount} users\n`;
            }
            if (whitelistedSkipped.length > 0) {
                summaryMessage += `‚ÑπÔ∏è Whitelisted users skipped: ${whitelistedSkipped.length}\n`;
            }
            summaryMessage += `\n‚è∞ Time: ${getTimestamp()}`;
            
            await this.sock.sendMessage(groupId, { text: summaryMessage });
            
            // Alert admin
            const adminId = config.ALERT_PHONE + '@s.whatsapp.net';
            
            // Try to get group invite link
            let groupLink = 'N/A';
            try {
                const inviteCode = await this.sock.groupInviteCode(groupId);
                groupLink = `https://chat.whatsapp.com/${inviteCode}`;
            } catch (err) {
                console.log('Could not get group invite link:', err.message);
            }
            
            const alertMessage = `üåç *Botforeign Command Executed*\n\n` +
                               `üìç Group: ${groupMetadata.subject}\n` +
                               `üîó Group Link: ${groupLink}\n` +
                               `üëÆ Executed by: Admin\n` +
                               `‚úÖ Removed: ${successCount} users\n` +
                               `‚ùå Failed: ${failCount} users\n` +
                               `‚ÑπÔ∏è Whitelisted skipped: ${whitelistedSkipped.length}\n` +
                               `‚è∞ Time: ${getTimestamp()}`;
            
            await this.sock.sendMessage(adminId, { text: alertMessage });
            
        } catch (error) {
            console.error('‚ùå Error in botforeign command:', error);
            await this.sock.sendMessage(groupId, { 
                text: '‚ùå Need to be an admin' 
            });
        }
        
        return true;
    }

    async handleDebugNumbers(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        // Check if in private chat
        if (this.isPrivateChat(msg)) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è The #debugnumbers command can only be used in groups.\n\nUsage: In a group, type #debugnumbers to see phone number formats' 
            });
            return true;
        }

        const groupId = msg.key.remoteJid;
        
        try {
            // Get group metadata
            const groupMetadata = await this.getCachedGroupMetadata(groupId);
            const participants = groupMetadata.participants;
            
            let debugReport = `üîç *Group Number Formats Debug*\n\n`;
            debugReport += `Total participants: ${participants.length}\n\n`;
            
            for (const participant of participants) {
                const userId = participant.id;
                const phoneNumber = userId.split('@')[0];
                const isAdmin = participant.admin === 'admin' || participant.admin === 'superadmin';
                const isLidFormat = userId.endsWith('@lid');
                
                debugReport += `üì± ${phoneNumber}\n`;
                debugReport += `   Full ID: ${userId}\n`;
                debugReport += `   Length: ${phoneNumber.length}\n`;
                debugReport += `   LID Format: ${isLidFormat}\n`;
                debugReport += `   Starts with 1: ${phoneNumber.startsWith('1')}\n`;
                debugReport += `   Starts with +1: ${phoneNumber.startsWith('+1')}\n`;
                debugReport += `   Starts with 6: ${phoneNumber.startsWith('6')}\n`;
                debugReport += `   Starts with +6: ${phoneNumber.startsWith('+6')}\n`;
                debugReport += `   Starts with 972: ${phoneNumber.startsWith('972')}\n`;
                debugReport += `   Admin: ${isAdmin}\n`;
                debugReport += `   10-digit US pattern: ${phoneNumber.length === 10 && /^[2-9]\d{9}$/.test(phoneNumber)}\n`;
                debugReport += `   LID exempt: ${isLidFormat ? 'Yes (encrypted privacy ID)' : 'No'}\n\n`;
                
                // Break if message gets too long
                if (debugReport.length > 3000) {
                    debugReport += `... (truncated - too many participants)\n`;
                    break;
                }
            }
            
            await this.sock.sendMessage(groupId, { text: debugReport });
            
        } catch (error) {
            console.error('‚ùå Error in debug numbers command:', error);
            await this.sock.sendMessage(groupId, { 
                text: '‚ùå Failed to debug numbers.' 
            });
        }
        
        return true;
    }

    async handleUnmute(msg, args, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }
        
        // Check if in private chat
        if (this.isPrivateChat(msg)) {
            await this.sendGroupOnlyMessage(msg, '#unmute');
            return true;
        }

        const groupId = msg.key.remoteJid;
        const hasQuotedMsg = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;

        if (hasQuotedMsg) {
            // Unmute specific user
            const quotedMsgId = msg.message?.extendedTextMessage?.contextInfo?.stanzaId;
            const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant;
            
            if (quotedParticipant) {
                await removeMutedUser(quotedParticipant);
                await this.sock.sendMessage(groupId, { 
                    text: `üîä User has been unmuted.\n` +
                          `üîä ◊î◊û◊©◊™◊û◊© ◊©◊ï◊ó◊®◊® ◊û◊î◊î◊©◊™◊ß◊î.`
                });
            } else {
                await this.sock.sendMessage(groupId, { 
                    text: `‚ö†Ô∏è Could not identify user to unmute.\n` +
                          `‚ö†Ô∏è ◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊ñ◊î◊ï◊™ ◊ê◊™ ◊î◊û◊©◊™◊û◊© ◊ú◊ë◊ô◊ò◊ï◊ú ◊î◊©◊™◊ß◊î.`
                });
            }
        } else {
            // Unmute entire group
            if (groupMuteStatus.has(groupId)) {
                groupMuteStatus.delete(groupId);
                await this.sock.sendMessage(groupId, { 
                    text: `üîä Group has been unmuted. Everyone can now send messages.\n` +
                          `üîä ◊î◊ß◊ë◊ï◊¶◊î ◊©◊ï◊ó◊®◊®◊î ◊û◊î◊î◊©◊™◊ß◊î. ◊õ◊ï◊ú◊ù ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊©◊ú◊ï◊ó ◊î◊ï◊ì◊¢◊ï◊™ ◊¢◊õ◊©◊ô◊ï.`
                });
            } else {
                await this.sock.sendMessage(groupId, { 
                    text: `‚ö†Ô∏è Group is not muted.\n` +
                          `‚ö†Ô∏è ◊î◊ß◊ë◊ï◊¶◊î ◊ú◊ê ◊û◊ï◊©◊™◊ß◊™.`
                });
            }
        }
        return true;
    }

    async handleUnwhitelist(msg, args, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        if (!args) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è Please provide a phone number. Example: #unwhitelist 972555123456' 
            });
            return true;
        }

        const success = await removeFromWhitelist(args);
        if (success) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚úÖ Removed ${args} from whitelist.` 
            });
        } else {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚ùå Failed to remove ${args} from whitelist (may not exist).` 
            });
        }
        return true;
    }
    async handleBlacklistAdd(msg, args, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        if (!args) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è Please provide a phone number. Example: #blacklist 972555123456' 
            });
            return true;
        }

        const { addToBlacklist } = require('./blacklistService');
        const success = await addToBlacklist(args, 'Added by admin command');
        if (success) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚úÖ Added ${args} to blacklist.` 
            });
        } else {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚ùå Failed to add ${args} to blacklist.` 
            });
        }
        return true;
    }
    
    async handleBlacklistRemove(msg, args, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        if (!args) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è Please provide a phone number. Example: #unblacklist 972555123456' 
            });
            return true;
        }

        const { removeFromBlacklist } = require('./blacklistService');
        const success = await removeFromBlacklist(args);
        if (success) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚úÖ Removed ${args} from blacklist.` 
            });
        } else {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚ùå Failed to remove ${args} from blacklist.` 
            });
        }
        return true;
    }
    
    async handleBlacklistList(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        const { blacklistCache } = require('./blacklistService');
        if (blacklistCache.size === 0) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: 'üìù Blacklist is empty.' 
            });
        } else {
            const list = Array.from(blacklistCache).slice(0, 50).map((num, index) => `${index + 1}. ${num}`).join('\n');
            const totalCount = blacklistCache.size;
            const message = totalCount > 50 
                ? `üìù *Blacklisted Users (showing first 50 of ${totalCount}):*\n\n${list}` 
                : `üìù *Blacklisted Users (${totalCount} total):*\n\n${list}`;
            await this.sock.sendMessage(msg.key.remoteJid, { text: message });
        }
        return true;
    }
    async handleSweep(msg, isSuperAdmin) {
        if (!isSuperAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå Only superadmins can use the sweep command.' 
            });
            return true;
        }
        
        // Check if in private chat
        if (this.isPrivateChat(msg)) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è The #sweep command can only be used in groups.\n\nUsage: In a group, type #sweep to clean up inactive users' 
            });
            return true;
        }

        await this.sock.sendMessage(msg.key.remoteJid, { 
            text: '‚ö†Ô∏è Sweep command not yet implemented in Baileys version.' 
        });
        return true;
    }
    async handleBotKick(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        // Check if in private chat
        if (this.isPrivateChat(msg)) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è The #botkick command can only be used in groups.\n\nUsage: In a group, type #botkick to scan and remove all blacklisted users' 
            });
            return true;
        }

        const groupId = msg.key.remoteJid;
        
        try {
            // Get group metadata
            const groupMetadata = await this.getCachedGroupMetadata(groupId);
            const participants = groupMetadata.participants;
            
            // Import blacklist check function
            const { isBlacklisted } = require('./blacklistService');
            
            await this.sock.sendMessage(groupId, { 
                text: `üîç Scanning ${participants.length} group members for blacklisted users...` 
            });
            
            // Find all blacklisted users
            const blacklistedUsers = [];
            
            for (const participant of participants) {
                const userId = participant.id;
                const phoneNumber = userId.split('@')[0];
                
                // Skip bot and admins
                if (participant.admin === 'admin' || participant.admin === 'superadmin') {
                    continue;
                }
                
                // Check if user is blacklisted
                if (await isBlacklisted(userId)) {
                    blacklistedUsers.push({
                        id: userId,
                        phone: phoneNumber
                    });
                    console.log(`üö´ Found blacklisted user in group: ${phoneNumber}`);
                }
            }
            
            if (blacklistedUsers.length === 0) {
                await this.sock.sendMessage(groupId, { 
                    text: '‚úÖ No blacklisted users found in this group.' 
                });
                return true;
            }
            
            // Kick blacklisted users
            await this.sock.sendMessage(groupId, { 
                text: `üö´ Found ${blacklistedUsers.length} blacklisted user(s). Removing them now...` 
            });
            
            let successCount = 0;
            let failCount = 0;
            
            for (const user of blacklistedUsers) {
                try {
                    await this.sock.groupParticipantsUpdate(groupId, [user.id], 'remove');
                    successCount++;
                    console.log(`‚úÖ Kicked blacklisted user: ${user.phone}`);
                    
                    // Send alert to alert phone
                    await sendKickAlert(this.sock, {
                        userPhone: user.phone,
                        userName: `User ${user.phone}`,
                        groupName: groupMetadata?.subject || 'Unknown Group',
                        groupId: groupId,
                        reason: 'blacklisted',
                        additionalInfo: `User was on blacklist`,
                        groupInviteLink: 'N/A' // Will be obtained by alert service
                    });
                    
                    // Send notification to admin instead of user
                    try {
                        await this.sock.sendMessage('0544345287@s.whatsapp.net', {
                            text: `üö´ Blacklisted user removed\n\n` +
                                  `üë§ User: ${user.phone}\n` +
                                  `üìç Group: ${groupMetadata?.subject || 'Unknown Group'}\n` +
                                  `üì± Reason: User on blacklist\n` +
                                  `‚è∞ Time: ${new Date().toLocaleString()}`
                        });
                    } catch (notificationError) {
                        console.error(`Failed to send admin notification:`, notificationError.message);
                    }
                    
                    // Small delay to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 500));
                } catch (error) {
                    failCount++;
                    console.error(`‚ùå Failed to kick ${user.phone}:`, error.message);
                }
            }
            
            // Send summary
            let summaryMessage = `üö´ *Blacklist Scan Complete*\n\n`;
            summaryMessage += `‚úÖ Successfully removed: ${successCount} users\n`;
            if (failCount > 0) {
                summaryMessage += `‚ùå Failed to remove: ${failCount} users\n`;
            }
            summaryMessage += `\n‚è∞ Time: ${getTimestamp()}`;
            
            await this.sock.sendMessage(groupId, { text: summaryMessage });
            
            // Alert admin
            const adminId = config.ALERT_PHONE + '@s.whatsapp.net';
            
            // Try to get group invite link
            let groupLink = 'N/A';
            try {
                const inviteCode = await this.sock.groupInviteCode(groupId);
                groupLink = `https://chat.whatsapp.com/${inviteCode}`;
            } catch (err) {
                console.log('Could not get group invite link:', err.message);
            }
            
            const alertMessage = `üö´ *Botkick (Blacklist Scan) Executed*\n\n` +
                               `üìç Group: ${groupMetadata.subject}\n` +
                               `üîó Group Link: ${groupLink}\n` +
                               `üëÆ Executed by: Admin\n` +
                               `üîç Found: ${blacklistedUsers.length} blacklisted users\n` +
                               `‚úÖ Removed: ${successCount} users\n` +
                               `‚ùå Failed: ${failCount} users\n` +
                               `‚è∞ Time: ${getTimestamp()}`;
            
            await this.sock.sendMessage(adminId, { text: alertMessage });
            
        } catch (error) {
            console.error('‚ùå Error in botkick command:', error);
            await this.sock.sendMessage(groupId, { 
                text: '‚ùå Need to be an admin' 
            });
        }
        
        return true;
    }
    
    async handleSessionCheck(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        const { sessionErrors, failedDecryptions } = require('../utils/sessionManager');
        const { getTimestamp } = require('../utils/logger');
        
        // Prepare session health report
        let report = `üîí *Session Health Check*\n\n`;
        report += `‚è∞ Time: ${getTimestamp()}\n\n`;
        
        // Check for problematic users
        if (sessionErrors.size === 0) {
            report += `‚úÖ No session errors detected\n`;
        } else {
            report += `‚ö†Ô∏è *Users with session errors:*\n`;
            let count = 0;
            for (const [userId, errors] of sessionErrors.entries()) {
                if (count++ < 10) { // Limit to first 10
                    report += `‚Ä¢ ${userId}: ${errors.length} errors\n`;
                }
            }
            if (sessionErrors.size > 10) {
                report += `... and ${sessionErrors.size - 10} more\n`;
            }
        }
        
        report += `\nüìä *Statistics:*\n`;
        report += `‚Ä¢ Failed decryptions: ${failedDecryptions.size}\n`;
        report += `‚Ä¢ Problematic sessions: ${sessionErrors.size}\n`;
        
        // Recommendations
        if (sessionErrors.size > 0 || failedDecryptions.size > 50) {
            report += `\nüí° *Recommendations:*\n`;
            report += `‚Ä¢ Consider restarting the bot\n`;
            report += `‚Ä¢ If errors persist, clear auth folder\n`;
            report += `‚Ä¢ Monitor for spam from listed users\n`;
        }
        
        await this.sock.sendMessage(msg.key.remoteJid, { text: report });
        return true;
    }
    
    async handleBotAdminCheck(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        const { isBotAdmin, getBotGroupStatus, debugBotId } = require('../utils/botAdminChecker');
        const { getTimestamp } = require('../utils/logger');
        
        // If in group, check this group
        if (msg.key.remoteJid.endsWith('@g.us')) {
            const groupId = msg.key.remoteJid;
            
            try {
                // Get detailed status
                const status = await getBotGroupStatus(this.sock, groupId);
                
                let report = `ü§ñ *Bot Admin Status*\n\n`;
                report += `üìç Group: ${status.groupName}\n`;
                report += `üÜî Bot ID: ${status.botId}\n`;
                report += `üëÆ Admin Status: ${status.adminStatus || 'Not in group'}\n`;
                report += `‚úÖ Is Admin: ${status.isAdmin ? 'Yes' : 'No'}\n`;
                report += `üë• Total Participants: ${status.participantCount}\n`;
                report += `üëÆ Total Admins: ${status.adminCount}\n`;
                report += `‚è∞ Time: ${getTimestamp()}\n\n`;
                
                if (!status.isAdmin) {
                    report += `‚ö†Ô∏è *Bot needs admin privileges to:*\n`;
                    report += `‚Ä¢ Delete messages\n`;
                    report += `‚Ä¢ Kick users\n`;
                    report += `‚Ä¢ Check blacklist on join\n\n`;
                    report += `üîß *To fix: Make bot admin in group settings*`;
                }
                
                await this.sock.sendMessage(groupId, { text: report });
                
            } catch (error) {
                await this.sock.sendMessage(groupId, { 
                    text: `‚ùå Error checking bot status: ${error.message}` 
                });
            }
        } else {
            // In private chat, show bot ID info
            const botInfo = debugBotId(this.sock);
            
            let report = `ü§ñ *Bot Information*\n\n`;
            report += `üÜî Bot ID: ${botInfo.fullId}\n`;
            report += `üì± Phone: ${botInfo.phone}\n`;
            report += `‚è∞ Time: ${getTimestamp()}\n\n`;
            report += `üí° Use this command in a group to check admin status`;
            
            await this.sock.sendMessage(msg.key.remoteJid, { text: report });
        }
        
        return true;
    }

    async handleSearch(msg, args, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: this.getRandomSassyResponse()
            });
            return true;
        }

        if (args.length === 0) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå Please provide a search query\n\nUsage: #search <query>\nExample: #search WhatsApp security tips' 
            });
            return true;
        }

        // Check if search service is initialized
        if (!searchService.isConnected) {
            await searchService.initialize();
        }

        const query = args.join(' ');
        const userId = msg.key.participant || msg.key.remoteJid;

        // Check rate limit
        const rateLimit = searchService.checkRateLimit(userId);
        if (!rateLimit.allowed) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚è≥ Rate limit exceeded. Please wait ${rateLimit.remainingTime} seconds before searching again.` 
            });
            return true;
        }

        try {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `üîç Searching for: "${query}"...` 
            });

            const results = await searchService.search(query);
            const formattedResults = searchService.formatSearchResults(results);

            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: formattedResults 
            });

            console.log(`[${getTimestamp()}] ‚úÖ Search completed for query: ${query}`);
        } catch (error) {
            console.error(`[${getTimestamp()}] ‚ùå Search failed:`, error);
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚ùå Search failed: ${error.message}\n\nüí° Note: MCP Chrome search requires setup. See MCP_SETUP.md for instructions.` 
            });
        }

        return true;
    }

    async handleVerifyLink(msg, args, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: this.getRandomSassyResponse()
            });
            return true;
        }

        if (args.length === 0) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå Please provide a URL to verify\n\nUsage: #verify <url>\nExample: #verify https://example.com' 
            });
            return true;
        }

        const url = args[0];

        // Basic URL validation
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå Invalid URL. Please include http:// or https://' 
            });
            return true;
        }

        // Check if search service is initialized
        if (!searchService.isConnected) {
            await searchService.initialize();
        }

        try {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `üîí Verifying link safety: ${url}...` 
            });

            const verification = await searchService.verifyLink(url);

            let resultMessage = `üîç *Link Verification Results*\n\n`;
            resultMessage += `üìé URL: ${url}\n`;
            resultMessage += `${verification.safe ? '‚úÖ' : '‚ùå'} Safety: ${verification.safe ? 'SAFE' : 'UNSAFE'}\n`;
            resultMessage += `üìÇ Category: ${verification.category}\n`;

            if (verification.threats && verification.threats.length > 0) {
                resultMessage += `\n‚ö†Ô∏è *Threats Detected:*\n`;
                verification.threats.forEach(threat => {
                    resultMessage += `‚Ä¢ ${threat}\n`;
                });
            }

            resultMessage += `\n‚è∞ Verified at: ${getTimestamp()}`;

            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: resultMessage 
            });

            console.log(`[${getTimestamp()}] ‚úÖ Link verified: ${url} - Safe: ${verification.safe}`);
        } catch (error) {
            console.error(`[${getTimestamp()}] ‚ùå Link verification failed:`, error);
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚ùå Verification failed: ${error.message}\n\nüí° Note: Link verification requires MCP setup. See MCP_SETUP.md for instructions.` 
            });
        }

        return true;
    }

    /**
     * Handle translation command
     */
    async handleTranslate(msg, args, isAdmin) {
        // Check if replying to a message
        const quotedMessage = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        let textToTranslateFromQuoted = null;
        
        if (quotedMessage) {
            // Extract text from quoted message
            textToTranslateFromQuoted = quotedMessage.conversation || 
                                      quotedMessage.extendedTextMessage?.text ||
                                      quotedMessage.imageMessage?.caption ||
                                      quotedMessage.videoMessage?.caption;
        }
        
        // If no args and no quoted message, show help
        if (args.length === 0 && !textToTranslateFromQuoted) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå Please provide text to translate\n\nüìù *Usage:*\n‚Ä¢ #translate <text> - Translate to Hebrew (default)\n‚Ä¢ #translate <lang> <text> - Translate to specific language\n‚Ä¢ *Reply* to a message with #translate - Translate that message\n‚Ä¢ *Reply* to a message with #translate <lang> - Translate to specific language\n\nüåê Example:\n‚Ä¢ #translate Hello world\n‚Ä¢ #translate en ◊©◊ú◊ï◊ù ◊¢◊ï◊ú◊ù\n‚Ä¢ #translate fr Bonjour le monde\n\nUse #langs to see supported languages' 
            });
            return true;
        }

        try {
            // Initialize translation service
            await translationService.initialize();
            
            let targetLang = 'he'; // Default to Hebrew
            let textToTranslate;
            const userId = msg.key.participant || msg.key.remoteJid;
            
            // Determine what text to translate and target language
            if (textToTranslateFromQuoted) {
                // Translating quoted message
                textToTranslate = textToTranslateFromQuoted;
                
                // Check if args specify a target language
                if (args.length > 0) {
                    const possibleLangCode = translationService.parseLanguageCode(args[0]);
                    if (possibleLangCode) {
                        targetLang = possibleLangCode;
                    }
                }
            } else {
                // Translating provided text
                textToTranslate = args.join(' ');
                
                // Check if first argument is a language code
                const possibleLangCode = translationService.parseLanguageCode(args[0]);
                if (possibleLangCode && args.length > 1) {
                    targetLang = possibleLangCode;
                    textToTranslate = args.slice(1).join(' ');
                }
            }
            
            // Check if text contains URLs or emails - skip translation
            const urlRegex = /(?:https?:\/\/|www\.|ftp:\/\/|[\w-]+\.[\w.-]+(?:\/[\w\-._~:/?#[\]@!$&'()*+,;=]*)?)/gi;
            const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
            
            if (urlRegex.test(textToTranslate)) {
                await this.sock.sendMessage(msg.key.remoteJid, { 
                    text: 'üîó Cannot translate URLs. Please provide regular text instead.' 
                });
                return true;
            }
            
            if (emailRegex.test(textToTranslate)) {
                await this.sock.sendMessage(msg.key.remoteJid, { 
                    text: 'üìß Cannot translate email addresses. Please provide regular text instead.' 
                });
                return true;
            }
            
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `üåê Translating to ${translationService.getSupportedLanguages()[targetLang] || targetLang}...` 
            });
            
            const result = await translationService.translateText(textToTranslate, targetLang, null, userId);
            
            // Simple clean response - just the translation
            const response = result.translatedText;
            
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: response 
            });
            
            console.log(`[${getTimestamp()}] ‚úÖ Translation completed: ${result.detectedLanguage} ‚Üí ${targetLang}`);
        } catch (error) {
            console.error(`[${getTimestamp()}] ‚ùå Translation failed:`, error);
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: `‚ùå Translation failed: ${error.message}\n\nüí° Note: Translation requires Google Translate API setup. Add GOOGLE_TRANSLATE_API_KEY to your environment.` 
            });
        }
        
        return true;
    }

    /**
     * Handle language list command
     */
    async handleLanguageList(msg, isAdmin) {
        try {
            const languages = translationService.getSupportedLanguages();
            
            let response = `üåê *Supported Languages*\n\n`;
            response += `Use these codes with #translate:\n\n`;
            
            // Group languages for better readability
            const entries = Object.entries(languages);
            for (let i = 0; i < entries.length; i += 2) {
                const [code1, name1] = entries[i];
                const line = entries[i + 1] 
                    ? `‚Ä¢ ${code1} = ${name1}\n‚Ä¢ ${entries[i + 1][0]} = ${entries[i + 1][1]}\n`
                    : `‚Ä¢ ${code1} = ${name1}\n`;
                response += line;
            }
            
            response += `\nüí° *Examples:*\n`;
            response += `‚Ä¢ #translate he Hello world\n`;
            response += `‚Ä¢ #translate ◊¢◊ë◊®◊ô◊™ Good morning\n`;
            response += `‚Ä¢ #translate fr Bonjour`;
            
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: response 
            });
            
        } catch (error) {
            console.error(`[${getTimestamp()}] ‚ùå Language list failed:`, error);
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå Failed to get language list. Please try again later.' 
            });
        }
        
        return true;
    }

    /**
     * Handle translation toggle command (bot only)
     */
    async handleTranslationToggle(msg, args) {
        // Check if message is from the bot itself
        if (!msg.key.fromMe) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: 'ü§ñ Auto-translation settings can only be changed by the bot itself.' 
            });
            return true;
        }

        const argsString = Array.isArray(args) ? args.join(' ') : args;
        const command = argsString.toLowerCase();
        const config = require('../config');
        
        try {
            if (command === 'on' || command === 'enable') {
                config.FEATURES.AUTO_TRANSLATION = true;
                
                let response = `‚úÖ *Auto-Translation Enabled*\n\n`;
                response += `üåê Bot will now automatically translate non-Hebrew messages to Hebrew immediately\n\n`;
                response += `üìã *How it works:*\n`;
                response += `‚Ä¢ When someone sends a non-Hebrew message\n`;
                response += `‚Ä¢ Bot detects if ALL words are non-Hebrew\n`;
                response += `‚Ä¢ Bot translates the message to Hebrew immediately\n`;
                response += `‚Ä¢ Mixed Hebrew/non-Hebrew messages are ignored\n\n`;
                response += `‚öôÔ∏è Use \`#autotranslate off\` to disable`;
                
                await this.sock.sendMessage(msg.key.remoteJid, { text: response });
                console.log(`[${getTimestamp()}] ‚úÖ Auto-translation enabled by admin`);
                
            } else if (command === 'off' || command === 'disable') {
                config.FEATURES.AUTO_TRANSLATION = false;
                
                let response = `‚ùå *Auto-Translation Disabled*\n\n`;
                response += `üö´ Bot will no longer automatically translate messages\n\n`;
                response += `üí° Manual translation commands still work:\n`;
                response += `‚Ä¢ \`#translate <text>\` - Translate to English\n`;
                response += `‚Ä¢ \`#translate <lang> <text>\` - Translate to specific language\n\n`;
                response += `‚öôÔ∏è Use \`#autotranslate on\` to re-enable`;
                
                await this.sock.sendMessage(msg.key.remoteJid, { text: response });
                console.log(`[${getTimestamp()}] ‚ùå Auto-translation disabled by admin`);
                
            } else if (command === 'status' || command === '') {
                const isEnabled = config.FEATURES.AUTO_TRANSLATION;
                
                let response = `üåê *Auto-Translation Status*\n\n`;
                response += `üìä Current Status: ${isEnabled ? '‚úÖ Enabled' : '‚ùå Disabled'}\n\n`;
                
                if (isEnabled) {
                    response += `üéØ *Active Settings:*\n`;
                    response += `‚Ä¢ Translates non-Hebrew messages ‚Üí Hebrew immediately\n`;
                    response += `‚Ä¢ Strict detection: ALL words must be non-Hebrew\n`;
                    response += `‚Ä¢ Rate limited: 10 translations/minute per user\n`;
                    response += `‚Ä¢ Minimum text length: 5 characters\n\n`;
                    response += `‚öôÔ∏è Use \`#autotranslate off\` to disable`;
                } else {
                    response += `üí° *Available Commands:*\n`;
                    response += `‚Ä¢ \`#autotranslate on\` - Enable auto-translation\n`;
                    response += `‚Ä¢ \`#translate <text>\` - Manual translation still works\n`;
                }
                
                await this.sock.sendMessage(msg.key.remoteJid, { text: response });
                
            } else {
                await this.sock.sendMessage(msg.key.remoteJid, { 
                    text: '‚ùå Invalid option. Use:\n‚Ä¢ `#autotranslate on` - Enable\n‚Ä¢ `#autotranslate off` - Disable\n‚Ä¢ `#autotranslate status` - Check status' 
                });
            }
            
        } catch (error) {
            console.error(`[${getTimestamp()}] ‚ùå Translation toggle failed:`, error);
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå Failed to toggle auto-translation. Please try again later.' 
            });
        }
        
        return true;
    }

    // #free system removed - users must contact admin directly

    /**
     * Handle admin approval commands (ok/NO userId)
     */
    async handleAdminApproval(msg, command, args) {
        // Only allow in private chats
        if (!this.isPrivateChat(msg)) {
            return false;
        }

        try {
            const decision = command.toLowerCase().startsWith('yes') ? 'yes' : 'no';
            const targetUserId = typeof args === 'string' ? args.trim() : args[0];
            
            if (!targetUserId) {
                await this.sock.sendMessage(msg.key.remoteJid, { 
                    text: `‚ùå Usage: \`${decision} <phone_number>\`\nExample: \`${decision} 972555123456\`` 
                });
                return true;
            }

            // Normalize the user ID
            const normalizedUserId = unblacklistRequestService.normalizeUserId(targetUserId);
            const fullUserId = normalizedUserId + '@s.whatsapp.net';

            // Process the admin response
            const adminPhone = msg.key.remoteJid.replace('@s.whatsapp.net', '');
            const responseProcessed = await unblacklistRequestService.processAdminResponse(
                normalizedUserId, 
                decision, 
                adminPhone
            );

            if (responseProcessed) {
                if (decision === 'yes') {
                    // Approve: Remove from blacklist
                    const removed = await removeFromBlacklist(fullUserId);
                    
                    if (removed) {
                        // Notify admin
                        await this.sock.sendMessage(msg.key.remoteJid, { 
                            text: `‚úÖ *Request APPROVED*\n\n` +
                                  `üë§ User ${normalizedUserId} has been removed from blacklist.\n` +
                                  `üì® User has been notified.` 
                        });

                        // Get rejoin links for user
                        let rejoinMessage = `üéâ *Request Approved!*\n\n` +
                                          `‚úÖ You have been removed from the blacklist.\n` +
                                          `üì± You can now rejoin groups.\n\n`;

                        try {
                            const { kickedUserService } = require('./kickedUserService');
                            // Get recent kicks only (last 30 days) for invite link spam
                            const rejoinInfo = await kickedUserService.getRejoinInfo(fullUserId, true, 'invite link');
                            
                            if (rejoinInfo && rejoinInfo.length > 0) {
                                // Only show the MOST RECENT group (first in sorted array)
                                const lastKick = rejoinInfo[0];
                                
                                if (lastKick.groupInviteLink && lastKick.groupInviteLink !== 'N/A') {
                                    const kickDate = new Date(lastKick.kickedAt).toLocaleDateString();
                                    rejoinMessage += `üîó *Rejoin Your Last Group:*\n\n`;
                                    rejoinMessage += `üì± *${lastKick.groupName}*\n`;
                                    rejoinMessage += `üìÖ Kicked: ${kickDate}\n`;
                                    rejoinMessage += `üîó ${lastKick.groupInviteLink}\n\n`;
                                    
                                    // Include admin list if available
                                    if (lastKick.adminList && lastKick.adminList.length > 0) {
                                        rejoinMessage += `üë• *Group Admins (if link fails):*\n`;
                                        lastKick.adminList.slice(0, 3).forEach((admin, index) => {
                                            if (admin.isLID) {
                                                rejoinMessage += `${index + 1}Ô∏è‚É£ ${admin.name} (${admin.phone})\n`;
                                            } else {
                                                rejoinMessage += `${index + 1}Ô∏è‚É£ ${admin.name}\n`;
                                            }
                                        });
                                        
                                        if (lastKick.adminList.length > 3) {
                                            rejoinMessage += `   ...and ${lastKick.adminList.length - 3} more admins\n`;
                                        }
                                        rejoinMessage += '\n';
                                    }
                                    
                                    rejoinMessage += `‚ö†Ô∏è *Important Notes:*\n`;
                                    rejoinMessage += `‚Ä¢ Link may require admin approval\n`;
                                    rejoinMessage += `‚Ä¢ Link may have expired - contact group admin if it fails\n`;
                                    rejoinMessage += `‚Ä¢ Wait a few minutes before attempting to rejoin\n\n`;
                                    
                                    if (rejoinInfo.length > 1) {
                                        rejoinMessage += `üìã For other groups, contact your admin or use group search.\n\n`;
                                    }
                                } else {
                                    rejoinMessage += `‚ö†Ô∏è *Last group's invite link is not available.*\n\n`;
                                }
                            } else {
                                rejoinMessage += `‚ÑπÔ∏è *No recent rejoin links available.*\n`;
                                rejoinMessage += `This may be because:\n`;
                                rejoinMessage += `‚Ä¢ No recent kicks for invite link violations\n`;
                                rejoinMessage += `‚Ä¢ Group invite links have expired\n`;
                                rejoinMessage += `‚Ä¢ More than 30 days have passed\n\n`;
                            }
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Failed to get rejoin links:', error.message);
                        }

                        rejoinMessage += `‚ö†Ô∏è *Important:* Remember your agreement to never share invite links in groups.\n` +
                                       `üö´ Sharing invite links will result in immediate re-blacklisting.\n\n` +
                                       `üéâ *◊î◊ë◊ß◊©◊î ◊ê◊ï◊©◊®◊î!*\n\n` +
                                       `‚úÖ ◊î◊ï◊°◊®◊™ ◊û◊î◊®◊©◊ô◊û◊î ◊î◊©◊ó◊ï◊®◊î.\n` +
                                       `üì± ◊ê◊™◊î ◊ô◊õ◊ï◊ú ◊¢◊õ◊©◊ô◊ï ◊ú◊î◊¶◊ò◊®◊£ ◊ú◊ß◊ë◊ï◊¶◊ï◊™.\n\n` +
                                       `‚ö†Ô∏è *◊ó◊©◊ï◊ë:* ◊ñ◊õ◊ï◊® ◊ê◊™ ◊î◊î◊°◊õ◊ù ◊©◊ú◊ö ◊ú◊¢◊ï◊ú◊ù ◊ú◊ê ◊ú◊©◊ú◊ï◊ó ◊ß◊ô◊©◊ï◊®◊ô ◊î◊ñ◊û◊†◊î ◊ë◊ß◊ë◊ï◊¶◊ï◊™.\n` +
                                       `üö´ ◊©◊ú◊ô◊ó◊™ ◊ß◊ô◊©◊ï◊®◊ô ◊î◊ñ◊û◊†◊î ◊™◊í◊®◊ï◊ù ◊ú◊î◊õ◊†◊°◊î ◊û◊ô◊ô◊ì◊ô◊™ ◊ú◊®◊©◊ô◊û◊î ◊î◊©◊ó◊ï◊®◊î.`;

                        // Notify user
                        await this.sock.sendMessage(fullUserId, { 
                            text: rejoinMessage 
                        }).catch(() => {
                            console.log(`Could not notify user ${normalizedUserId} - they may have blocked the bot`);
                        });

                        console.log(`[${getTimestamp()}] ‚úÖ Admin ${adminPhone} approved unblacklist for ${normalizedUserId}`);
                    } else {
                        await this.sock.sendMessage(msg.key.remoteJid, { 
                            text: `‚ùå Failed to remove ${normalizedUserId} from blacklist. They may not be blacklisted.` 
                        });
                    }
                } else {
                    // Deny: Keep on blacklist
                    await this.sock.sendMessage(msg.key.remoteJid, { 
                        text: `‚ùå *Request DENIED*\n\n` +
                              `üë§ User ${normalizedUserId} remains on blacklist.\n` +
                              `üì® User has been notified.` 
                    });

                    // Notify user
                    await this.sock.sendMessage(fullUserId, { 
                        text: `‚ùå *Request Denied*\n\n` +
                              `üö´ Your unblacklist request has been denied.\n` +
                              `üìÖ You can submit a new request in 24 hours.\n\n` +
                              `üí° Please ensure you understand and agree to follow all group rules before requesting again.\n\n` +
                              `‚ùå *◊î◊ë◊ß◊©◊î ◊†◊ì◊ó◊™◊î*\n\n` +
                              `üö´ ◊ë◊ß◊©◊™ ◊î◊°◊®◊î ◊û◊î◊®◊©◊ô◊û◊î ◊î◊©◊ó◊ï◊®◊î ◊©◊ú◊ö ◊†◊ì◊ó◊™◊î.\n` +
                              `üìÖ ◊ê◊™◊î ◊ô◊õ◊ï◊ú ◊ú◊î◊í◊ô◊© ◊ë◊ß◊©◊î ◊ó◊ì◊©◊î ◊ë◊¢◊ï◊ì 24 ◊©◊¢◊ï◊™.\n\n` +
                              `üí° ◊ê◊†◊ê ◊ï◊ì◊ê ◊©◊ê◊™◊î ◊û◊ë◊ô◊ü ◊ï◊û◊°◊õ◊ô◊ù ◊ú◊õ◊ú ◊õ◊ú◊ú◊ô ◊î◊ß◊ë◊ï◊¶◊î ◊ú◊§◊†◊ô ◊î◊í◊©◊™ ◊ë◊ß◊©◊î ◊©◊ï◊ë.` 
                    }).catch(() => {
                        console.log(`Could not notify user ${normalizedUserId} - they may have blocked the bot`);
                    });

                    console.log(`[${getTimestamp()}] ‚ùå Admin ${adminPhone} denied unblacklist for ${normalizedUserId}`);
                }
            } else {
                await this.sock.sendMessage(msg.key.remoteJid, { 
                    text: `‚ùå Failed to process response. User ${normalizedUserId} may not have a pending request.` 
                });
            }

        } catch (error) {
            console.error(`‚ùå Error handling admin approval:`, error);
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå Error processing admin response. Please try again.' 
            });
        }

        return true;
    }

    async handleJokeStats(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        try {
            const { motivationalPhraseService } = require('./motivationalPhraseService');
            const stats = await motivationalPhraseService.getPhraseStats();

            let report = `üìä *Joke Statistics*\n\n`;
            report += `üìö Total Phrases: ${stats.totalPhrases}\n`;
            report += `‚úÖ Used Phrases: ${stats.usedPhrases}\n`;
            report += `üé≠ Total Usage: ${stats.totalUsages}\n\n`;

            if (stats.mostUsed) {
                report += `üèÜ *Most Popular:*\n`;
                report += `"${stats.mostUsed.text}" (${stats.mostUsed.count} times)\n\n`;
            }

            if (stats.leastUsed) {
                report += `üÜï *Least Used:*\n`;
                report += `"${stats.leastUsed.text}" (${stats.leastUsed.count} times)\n\n`;
            }

            report += `üí° *Usage:* Reply to "◊û◊©◊¢◊û◊ù" messages triggers random jokes`;

            await this.sock.sendMessage(msg.key.remoteJid, { text: report });

        } catch (error) {
            console.error('‚ùå Error fetching joke stats:', error.message);
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå Error fetching joke statistics. Please try again.' 
            });
        }

        return true;
    }

    async handleRejoinLinks(msg, args, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '◊û◊î ◊ê◊†◊ô ◊¢◊ï◊ë◊ì ◊ê◊¶◊ú◊ö?!' 
            });
            return true;
        }

        if (!args) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è Usage: #rejoinlinks <phone_number>\nExample: #rejoinlinks 972555123456' 
            });
            return true;
        }

        try {
            const argsString = Array.isArray(args) ? args.join(' ') : args;
            const phoneNumber = argsString.trim();
            const userId = `${phoneNumber}@s.whatsapp.net`;
            const { kickedUserService } = require('./kickedUserService');

            // Get all kick records for this user
            const allKicks = await kickedUserService.getRejoinInfo(userId, false); // Get all, not just recent
            
            if (!allKicks || allKicks.length === 0) {
                await this.sock.sendMessage(msg.key.remoteJid, { 
                    text: `‚ÑπÔ∏è No kick records found for ${phoneNumber}` 
                });
                return true;
            }

            let report = `üìã *Rejoin Links for ${phoneNumber}*\n\n`;
            
            allKicks.forEach((kick, index) => {
                const kickDate = new Date(kick.kickedAt).toLocaleDateString();
                const canRejoinStatus = kick.canRejoin ? '‚úÖ Ready' : '‚è≥ Pending approval';
                
                report += `${index + 1}Ô∏è‚É£ *${kick.groupName}*\n`;
                report += `   üìÖ Kicked: ${kickDate}\n`;
                report += `   üîç Reason: ${kick.reason}\n`;
                report += `   üéØ Status: ${canRejoinStatus}\n`;
                
                if (kick.canRejoin && kick.groupInviteLink && kick.groupInviteLink !== 'N/A') {
                    report += `   üîó Link: ${kick.groupInviteLink}\n`;
                }
                
                report += '\n';
            });

            report += `üìä *Summary:* ${allKicks.length} total kicks, ${allKicks.filter(k => k.canRejoin).length} ready for rejoin`;

            await this.sock.sendMessage(msg.key.remoteJid, { text: report });

        } catch (error) {
            console.error('‚ùå Error fetching rejoin links:', error.message);
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå Error fetching rejoin links. Please try again.' 
            });
        }

        return true;
    }


    /**
     * Handle jokes enable command
     */
    async handleJokesOn(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: this.getRandomSassyResponse()
            });
            return true;
        }

        // Only works in groups
        if (!msg.key.remoteJid.endsWith('@g.us')) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è This command can only be used in groups.' 
            });
            return true;
        }

        try {
            const groupId = msg.key.remoteJid;
            const senderPhone = (msg.key.participant || msg.key.remoteJid).split('@')[0];
            
            // Get group metadata for name
            let groupName = 'Unknown';
            try {
                const groupMetadata = await this.getCachedGroupMetadata(groupId);
                groupName = groupMetadata.subject || 'Unknown';
            } catch (error) {
                console.log(`Could not get group metadata: ${error.message}`);
            }

            const success = await groupJokeSettingsService.setJokesEnabled(groupId, true, senderPhone, groupName);
            
            if (success) {
                await this.sock.sendMessage(msg.key.remoteJid, { 
                    text: `üé≠‚úÖ ◊ë◊ì◊ô◊ó◊ï◊™ ◊û◊©◊¢◊û◊ù ◊î◊ï◊§◊¢◊ú◊ï ◊ë◊ß◊ë◊ï◊¶◊î!\n\n◊õ◊©◊û◊ô◊©◊î◊ï ◊õ◊ï◊™◊ë "◊û◊©◊¢◊û◊ù", ◊î◊ë◊ï◊ò ◊ô◊¢◊†◊î ◊¢◊ù ◊ë◊ì◊ô◊ó◊î.` 
                });
            } else {
                await this.sock.sendMessage(msg.key.remoteJid, { 
                    text: `‚ö†Ô∏è ◊ë◊ì◊ô◊ó◊ï◊™ ◊î◊ï◊§◊¢◊ú◊ï ◊û◊ß◊ï◊û◊ô◊™, ◊ê◊ö ◊¢◊ì◊õ◊ï◊ü Firebase ◊†◊õ◊©◊ú. ◊î◊î◊í◊ì◊®◊î ◊™◊ê◊ë◊ì ◊ë◊î◊§◊¢◊ú◊î ◊û◊ó◊ì◊©.` 
                });
            }
        } catch (error) {
            console.error('Error enabling jokes:', error);
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊î◊§◊¢◊ú◊™ ◊ë◊ì◊ô◊ó◊ï◊™. ◊†◊°◊î ◊©◊ï◊ë.' 
            });
        }

        return true;
    }

    /**
     * Handle jokes disable command
     */
    async handleJokesOff(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: this.getRandomSassyResponse()
            });
            return true;
        }

        // Only works in groups
        if (!msg.key.remoteJid.endsWith('@g.us')) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è ◊î◊§◊ß◊ï◊ì◊î ◊î◊ñ◊ï ◊§◊ï◊¢◊ú◊™ ◊®◊ß ◊ë◊ß◊ë◊ï◊¶◊ï◊™.' 
            });
            return true;
        }

        try {
            const groupId = msg.key.remoteJid;
            const senderPhone = (msg.key.participant || msg.key.remoteJid).split('@')[0];
            
            // Get group metadata for name
            let groupName = 'Unknown';
            try {
                const groupMetadata = await this.getCachedGroupMetadata(groupId);
                groupName = groupMetadata.subject || 'Unknown';
            } catch (error) {
                console.log(`Could not get group metadata: ${error.message}`);
            }

            const success = await groupJokeSettingsService.setJokesEnabled(groupId, false, senderPhone, groupName);
            
            if (success) {
                await this.sock.sendMessage(msg.key.remoteJid, { 
                    text: `üé≠‚ùå ◊ë◊ì◊ô◊ó◊ï◊™ ◊û◊©◊¢◊û◊ù ◊õ◊ï◊ë◊ï ◊ë◊ß◊ë◊ï◊¶◊î!\n\n◊î◊ë◊ï◊ò ◊ô◊™◊¢◊ú◊ù ◊û◊î◊ï◊ì◊¢◊ï◊™ "◊û◊©◊¢◊û◊ù" ◊ë◊ß◊ë◊ï◊¶◊î ◊ñ◊ï.` 
                });
            } else {
                await this.sock.sendMessage(msg.key.remoteJid, { 
                    text: `‚ö†Ô∏è ◊ë◊ì◊ô◊ó◊ï◊™ ◊õ◊ï◊ë◊ï ◊û◊ß◊ï◊û◊ô◊™, ◊ê◊ö ◊¢◊ì◊õ◊ï◊ü Firebase ◊†◊õ◊©◊ú. ◊î◊î◊í◊ì◊®◊î ◊™◊ê◊ë◊ì ◊ë◊î◊§◊¢◊ú◊î ◊û◊ó◊ì◊©.` 
                });
            }
        } catch (error) {
            console.error('Error disabling jokes:', error);
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊õ◊ô◊ë◊ï◊ô ◊ë◊ì◊ô◊ó◊ï◊™. ◊†◊°◊î ◊©◊ï◊ë.' 
            });
        }

        return true;
    }

    /**
     * Handle jokes status command
     */
    async handleJokesStatus(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: this.getRandomSassyResponse()
            });
            return true;
        }

        // Only works in groups
        if (!msg.key.remoteJid.endsWith('@g.us')) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ö†Ô∏è ◊î◊§◊ß◊ï◊ì◊î ◊î◊ñ◊ï ◊§◊ï◊¢◊ú◊™ ◊®◊ß ◊ë◊ß◊ë◊ï◊¶◊ï◊™.' 
            });
            return true;
        }

        try {
            const groupId = msg.key.remoteJid;
            
            // Get group metadata for name
            let groupName = 'Unknown';
            try {
                const groupMetadata = await this.getCachedGroupMetadata(groupId);
                groupName = groupMetadata.subject || 'Unknown';
            } catch (error) {
                console.log(`Could not get group metadata: ${error.message}`);
            }

            const jokesEnabled = await groupJokeSettingsService.areJokesEnabled(groupId);
            const settings = await groupJokeSettingsService.getGroupSettings(groupId);
            
            let statusText = `üé≠ *◊°◊ò◊ò◊ï◊° ◊ë◊ì◊ô◊ó◊ï◊™ ◊¢◊ë◊ï◊®: ${groupName}*\n\n`;
            statusText += `◊û◊¶◊ë: ${jokesEnabled ? '‚úÖ ◊û◊ï◊§◊¢◊ú' : '‚ùå ◊õ◊ë◊ï◊ô'}\n`;
            
            if (settings.updated_at) {
                const updateDate = new Date(settings.updated_at).toLocaleString('he-IL');
                statusText += `◊¢◊ï◊ì◊õ◊ü ◊ú◊ê◊ó◊®◊ï◊†◊î: ${updateDate}\n`;
                statusText += `◊¢◊ï◊ì◊õ◊ü ◊¢◊ú ◊ô◊ì◊ô: +${settings.updated_by}\n`;
            } else {
                statusText += `◊û◊¶◊ë: ◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú (◊ú◊ú◊ê ◊©◊ô◊†◊ï◊ô◊ô◊ù)\n`;
            }
            
            statusText += `\nüí° *◊§◊ß◊ï◊ì◊ï◊™:*\n`;
            statusText += `‚Ä¢ #jokeson - ◊î◊§◊¢◊ú ◊ë◊ì◊ô◊ó◊ï◊™ ◊û◊©◊¢◊û◊ù\n`;
            statusText += `‚Ä¢ #jokesoff - ◊õ◊ë◊î ◊ë◊ì◊ô◊ó◊ï◊™ ◊û◊©◊¢◊û◊ù\n`;
            statusText += `‚Ä¢ #jokesstatus - ◊î◊¶◊í ◊û◊¶◊ë ◊†◊ï◊õ◊ó◊ô`;
            
            await this.sock.sendMessage(msg.key.remoteJid, { text: statusText });
            
        } catch (error) {
            console.error('Error getting joke status:', error);
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊ê◊ó◊ñ◊ï◊® ◊°◊ò◊ò◊ï◊° ◊ë◊ì◊ô◊ó◊ï◊™. ◊†◊°◊î ◊©◊ï◊ë.' 
            });
        }

        return true;
    }
    
    /**
     * Handle #msg1 command - Send pre-written admin warning message
     */
    async handleMsg1(msg, isAdmin) {
        if (!isAdmin) {
            await this.sock.sendMessage(msg.key.remoteJid, { 
                text: '‚ùå ◊§◊ß◊ï◊ì◊î ◊ñ◊ï ◊û◊ô◊ï◊¢◊ì◊™ ◊ú◊û◊†◊î◊ú◊ô◊ù ◊ë◊ú◊ë◊ì.' 
            });
            return true;
        }
        
        const warningMessage = `üö® ◊ê◊ñ◊î◊®◊™ ◊î◊ë◊ï◊ò! üö®
◊®◊ß ◊û◊ô ◊©◊ô◊© ◊ú◊ï ◊õ◊™◊® ◊ê◊ì◊û◊ô◊ü üëë ◊ô◊õ◊ï◊ú ◊ú◊©◊ú◊ï◊ó ◊î◊ñ◊û◊†◊î ◊ú◊ß◊ë◊ï◊¶◊™ ◊ï◊ï◊ê◊ò◊°◊ê◊§ ◊õ◊ê◊ü.
◊õ◊ú ◊î◊©◊ê◊® ‚Äî ◊©◊ú◊ó◊™◊ù ◊ß◊ô◊©◊ï◊®? ◊î◊ë◊ï◊ò ◊û◊ï◊ó◊ß ◊ê◊™ ◊î◊î◊ï◊ì◊¢◊î, ◊ï◊ê◊™◊õ◊ù ◊©◊ï◊ú◊ó ◊ú"◊ó◊ì◊® ◊û◊ó◊©◊ë◊ï◊™" ◊û◊ó◊ï◊• ◊ú◊ß◊ë◊ï◊¶◊î üö™ü§î
◊¢◊©◊ï ◊ú◊¢◊¶◊û◊õ◊ù ◊ò◊ï◊ë◊î, ◊™◊©◊ê◊ô◊®◊ï ◊ê◊™ ◊î◊î◊ñ◊û◊†◊ï◊™ ◊ú◊ê◊ì◊û◊ô◊†◊ô◊ù!

ü§°üö∑
#◊®◊ß_◊ê◊î◊ë◊î_◊ï◊ú◊ê_◊î◊ñ◊û◊†◊ï◊™`;

        await this.sock.sendMessage(msg.key.remoteJid, { text: warningMessage });
        return true;
    }
}

module.exports = CommandHandler;